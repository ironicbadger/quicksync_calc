<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Intel Quick Sync Video benchmark results - Compare hardware encoding performance across CPU generations"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600;700&display=swap" rel="stylesheet"><title>QuickSync Benchmarks - Intel Quick Sync Video Performance</title><!-- Plausible Analytics --><script defer data-domain="quicksync.ktz.me" src="https://plausible.ktz.cloud/js/script.js"></script><style>:root{--color-bg: #0f172a;--color-bg-secondary: #1e293b;--color-text: #f1f5f9;--color-text-muted: #94a3b8;--color-accent: #3b82f6;--color-accent-hover: #60a5fa;--color-border: #334155;--font-mono: "Fira Code", ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Monaco, "Courier New", monospace}*{box-sizing:border-box;margin:0;padding:0}html{font-family:var(--font-mono);background-color:var(--color-bg);color:var(--color-text);line-height:1.6}body{min-height:100vh}a{color:var(--color-accent);text-decoration:none}a:hover{color:var(--color-accent-hover);text-decoration:underline}code{font-family:var(--font-mono);font-size:.875em;background-color:var(--color-bg-secondary);padding:.125rem .375rem;border-radius:.25rem}.container{max-width:1400px;margin:0 auto;padding:0 1rem}.card{background-color:var(--color-bg-secondary);border:1px solid var(--color-border);border-radius:.5rem;padding:1.5rem}button{cursor:pointer;font-family:inherit}select,input{font-family:inherit;font-size:1rem}
</style>
<link rel="stylesheet" href="/_astro/index.Ctx0_dBB.css"></head> <body> <header style="border-bottom: 1px solid var(--color-border); padding: 1rem 0;"> <div class="container" style="display: flex; justify-content: space-between; align-items: center;"> <a href="/" style="font-size: 1.25rem; font-weight: 600; color: var(--color-text);">
QuickSync Benchmarks
</a> <nav style="display: flex; gap: 1.5rem;"> <a href="/">Dashboard</a> <a href="/leaderboard">Leaderboard</a> <a href="/about">About</a> <a href="https://github.com/ironicbadger/quicksync_calc" target="_blank" rel="noopener">GitHub</a> </nav> </div> </header> <main style="padding: 2rem 0;">   <div id="info-banner" class="info-banner"> <div class="info-banner-content"> <div class="info-banner-main"> <div class="info-section"> <h2>Intel Quick Sync Video Benchmarks</h2> <p>Community-driven database of hardware transcoding performance. Compare FPS, power usage, and efficiency across Intel CPU generations for Plex/Jellyfin transcoding.</p><br> <p>Brought to you by <a href="https://github.com/ironicbadger" target="_blank" rel="noopener noreferrer">ironicbadger</a> and <a href="https://github.com/cptmorgan-rh" target="_blank" rel="noopener noreferrer">cptmorgan</a>.</p> </div> <div class="info-section"> <h3>How to Use</h3> <ul> <li><strong>Filter:</strong> Use the sidebar to filter by CPU model, generation, or test type</li> <li><strong>Click charts:</strong> Click any bar to filter by that generation</li> <li><strong>Compare:</strong> Select a generation to see detailed stats vs 8th Gen baseline</li> </ul> </div> <div class="info-section"> <h3>Submit Your Results</h3> <pre><code>git clone https://github.com/ironicbadger/quicksync_calc.git
cd quicksync_calc
./quicksync-benchmark.sh</code></pre> <p class="info-note">After benchmarks complete, you'll get a link to verify and submit your results. Requires Docker + Intel CPU with Quick Sync. <a href="/about">Full instructions</a></p> </div> </div> <button id="hide-banner" class="hide-banner-btn" title="Hide this banner"> <span class="hide-icon">Ã—</span> </button> </div> </div>  <button id="show-banner" class="show-banner-btn" style="display: none;"> <span>?</span> Info & Submit
</button> <div class="dashboard-layout"> <!-- Left Sidebar: Filters --> <aside class="sidebar"> <div class="sidebar-header"> <h2>Filters</h2> <button id="clear-filters" class="btn-link">Clear All</button> </div> <!-- Submitter ID --> <div class="filter-section"> <h3>Submitter ID</h3> <input type="text" id="submitter-search" placeholder="Search submitters..." class="search-input"> <div id="submitter-list" class="checkbox-list submitter-list"> <!-- Populated by JS --> </div> </div> <!-- CPU Search --> <div class="filter-section"> <h3>CPU Model</h3> <input type="text" id="cpu-search" placeholder="Search CPUs..." class="search-input"> <div id="cpu-list" class="checkbox-list cpu-list"> <!-- Populated by JS --> </div> </div> <!-- CPU Generation --> <div class="filter-section"> <h3>Generation</h3> <div id="generation-list" class="checkbox-list"> <!-- Populated by JS --> </div> </div> <!-- Architecture --> <div class="filter-section"> <h3>Architecture</h3> <div id="architecture-list" class="checkbox-list"> <!-- Populated by JS --> </div> </div> <!-- Test Type --> <div class="filter-section"> <h3>Test Type</h3> <div id="test-list" class="checkbox-list"> <!-- Populated by JS --> </div> </div> </aside> <!-- Main Content --> <main class="main-content"> <!-- Summary Stats --> <div class="summary-cards"> <div class="card summary-card"> <div class="summary-value" id="total-results">-</div> <div class="summary-label">Total Results</div> </div> <div class="card summary-card"> <div class="summary-value" id="unique-cpus">-</div> <div class="summary-label">Unique CPUs</div> </div> <div class="card summary-card"> <div class="summary-value" id="filtered-results">-</div> <div class="summary-label">Filtered Results</div> </div> <div class="card summary-card"> <div class="summary-value" id="architectures-count">-</div> <div class="summary-label">Architectures</div> </div> </div> <!-- Charts Grid --> <div class="charts-grid"> <div class="chart-container card" data-astro-cid-3wmhvgao> <h3 style="margin-bottom: 1rem; font-size: 1rem; color: var(--color-text-muted);" data-astro-cid-3wmhvgao>Average FPS by Generation</h3> <div class="chart-wrapper" data-astro-cid-3wmhvgao> <canvas id="fps-chart" data-metric="avg_fps" data-ylabel="Frames per Second" data-astro-cid-3wmhvgao></canvas> </div> </div>  <div class="chart-container card" data-astro-cid-3wmhvgao> <h3 style="margin-bottom: 1rem; font-size: 1rem; color: var(--color-text-muted);" data-astro-cid-3wmhvgao>Power Usage by Generation</h3> <div class="chart-wrapper" data-astro-cid-3wmhvgao> <canvas id="watts-chart" data-metric="avg_watts" data-ylabel="Watts" data-astro-cid-3wmhvgao></canvas> </div> </div>  <div class="chart-container card" data-astro-cid-3wmhvgao> <h3 style="margin-bottom: 1rem; font-size: 1rem; color: var(--color-text-muted);" data-astro-cid-3wmhvgao>Efficiency (FPS/Watt) by Generation</h3> <div class="chart-wrapper" data-astro-cid-3wmhvgao> <canvas id="efficiency-chart" data-metric="fps_per_watt" data-ylabel="FPS per Watt" data-astro-cid-3wmhvgao></canvas> </div> </div>  </div> <!-- Generation Stats (shown when single generation selected) --> <div id="generation-stats" class="generation-stats" style="display: none;"> <div class="gen-stats-header"> <h3 id="gen-stats-title">Generation Statistics</h3> <span id="gen-stats-subtitle" class="gen-stats-subtitle"></span> </div> <div class="gen-stats-content"> <!-- Summary metrics row --> <div id="gen-stats-summary" class="gen-stats-summary"> <!-- Populated by JS --> </div> <!-- Comparison charts - stacked --> <div class="gen-stats-charts"> <div class="gen-stats-chart-container"> <canvas id="gen-fps-chart"></canvas> </div> <div class="gen-stats-chart-container"> <canvas id="gen-watts-chart"></canvas> </div> <div class="gen-stats-chart-container"> <canvas id="gen-efficiency-chart"></canvas> </div> </div> </div> </div> <!-- CPU Stats (shown when CPU is selected) --> <div id="cpu-stats" class="generation-stats cpu-stats-panel" style="display: none;"> <div class="gen-stats-header"> <h3 id="cpu-stats-title">CPU Statistics</h3> <span id="cpu-stats-subtitle" class="gen-stats-subtitle"></span> </div> <div class="gen-stats-content"> <!-- Summary metrics row --> <div id="cpu-stats-summary" class="gen-stats-summary"> <!-- Populated by JS --> </div> <!-- Comparison charts - stacked --> <div class="gen-stats-charts"> <div class="gen-stats-chart-container"> <canvas id="cpu-fps-chart"></canvas> </div> <div class="gen-stats-chart-container"> <canvas id="cpu-watts-chart"></canvas> </div> <div class="gen-stats-chart-container"> <canvas id="cpu-efficiency-chart"></canvas> </div> </div> </div> </div> <!-- Results Table --> <div class="results-table-wrapper card"> <div class="table-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;"> <h3 style="font-size: 1rem; color: var(--color-text-muted);">
Results <span id="results-count">(loading...)</span> </h3> <div style="display: flex; gap: 0.5rem; align-items: center;"> <label for="results-limit" style="font-size: 0.875rem; color: var(--color-text-muted);">Show:</label> <select id="results-limit"> <option value="25">25</option> <option value="50">50</option> <option value="100" selected>100</option> <option value="250">250</option> </select> </div> </div> <div class="table-scroll"> <table id="results-table"> <thead> <tr> <th data-sort="cpu_raw">CPU</th> <th data-sort="architecture">Architecture</th> <th data-sort="test_name">Test</th> <th data-sort="avg_fps" class="numeric">FPS</th> <th data-sort="avg_watts" class="numeric">Watts</th> <th data-sort="fps_per_watt" class="numeric">FPS/Watt</th> <th data-sort="avg_speed" class="numeric">Speed</th> <th data-sort="score" class="numeric">Score</th> <th data-sort="submitted_at">Submitted</th> </tr> </thead> <tbody id="results-body"> <tr> <td colspan="9" style="text-align: center; padding: 2rem;">Loading...</td> </tr> </tbody> </table> </div> <div class="pagination" style="margin-top: 1rem; display: flex; justify-content: center; gap: 0.5rem;"> <button id="prev-page" class="btn-secondary" disabled>&larr; Previous</button> <span id="page-info" style="padding: 0.5rem 1rem; color: var(--color-text-muted);">Page 1</span> <button id="next-page" class="btn-secondary">Next &rarr;</button> </div> </div>  </main> </div>  </main> <footer style="border-top: 1px solid var(--color-border); padding: 2rem 0; margin-top: 4rem;"> <div class="container" style="text-align: center; color: var(--color-text-muted);"> <p>Intel Quick Sync Video Benchmark Database</p> <p style="margin-top: 0.5rem; font-size: 0.875rem;">
Data sourced from community submissions &bull;
<a href="https://github.com/ironicbadger/quicksync_calc">Contribute on GitHub</a> </p> </div> </footer> </body></html>  <script>(function(){const API_URL = "https://quicksync-api.ktz.me";

  // Dashboard state
  const state = {
    filters: {
      generation: [],
      architecture: [],
      test: [],
      cpu: [],
      submitter: [],
    },
    filterOptions: {
      generations: [],
      architectures: [],
      tests: [],
      submitters: [],
    },
    filterCounts: {
      generations: {},
      architectures: {},
      tests: {},
      cpus: {},
      submitters: {},
    },
    cpuScores: {},
    sort: { column: 'submitted_at', order: 'desc' },
    pagination: { limit: 100, offset: 0 },
    boxplotData: {},
  };

  // Test type colors - distinct palette for easy differentiation
  const testColors = {
    'h264_1080p': { bg: 'rgba(34, 197, 94, 0.7)', border: 'rgb(34, 197, 94)' },      // Green
    'h264_1080p_cpu': { bg: 'rgba(245, 158, 11, 0.7)', border: 'rgb(245, 158, 11)' }, // Amber
    'h264_4k': { bg: 'rgba(234, 88, 12, 0.7)', border: 'rgb(234, 88, 12)' },          // Orange
    'hevc_8bit': { bg: 'rgba(59, 130, 246, 0.7)', border: 'rgb(59, 130, 246)' },      // Blue
    'hevc_4k_10bit': { bg: 'rgba(168, 85, 247, 0.7)', border: 'rgb(168, 85, 247)' },  // Purple
  };

  // Fetch summary stats
  async function fetchSummary() {
    try {
      const res = await fetch(`${API_URL}/api/stats/summary`);
      const data = await res.json();

      if (data.success) {
        document.getElementById('total-results').textContent = data.summary.total_results.toLocaleString();
        document.getElementById('unique-cpus').textContent = data.summary.unique_cpus.toLocaleString();
        document.getElementById('architectures-count').textContent = data.summary.architectures_count.toLocaleString();
      }
    } catch (e) {
      console.error('Failed to fetch summary:', e);
    }
  }

  // Fetch filter options (initial list of all options)
  async function fetchFilters() {
    try {
      const res = await fetch(`${API_URL}/api/results/filters`);
      const data = await res.json();

      if (data.success) {
        state.filterOptions.generations = data.filters.generations.sort((a, b) => b - a);
        state.filterOptions.architectures = data.filters.architectures.sort();
        state.filterOptions.tests = data.filters.tests;

        // Initial render
        renderFilters();
      }
    } catch (e) {
      console.error('Failed to fetch filters:', e);
    }
  }

  // Fetch filter counts based on current selections
  async function fetchFilterCounts() {
    const params = new URLSearchParams();
    if (state.filters.generation.length > 0) {
      params.set('generation', state.filters.generation.join(','));
    }
    if (state.filters.architecture.length > 0) {
      params.set('architecture', state.filters.architecture.join(','));
    }
    if (state.filters.test.length > 0) {
      params.set('test', state.filters.test.join(','));
    }

    try {
      const res = await fetch(`${API_URL}/api/results/filter-counts?${params}`);
      const data = await res.json();

      if (data.success) {
        state.filterCounts = data.counts;
        updateFilterCounts();
      }
    } catch (e) {
      console.error('Failed to fetch filter counts:', e);
    }
  }

  // Render filter checkboxes
  function renderFilters() {
    // Generations
    const genList = document.getElementById('generation-list');
    genList.innerHTML = state.filterOptions.generations.map(g => `
      <label class="checkbox-item" data-value="${g}">
        <input type="checkbox" value="${g}" data-filter="generation" />
        <span>${g}th Gen</span>
        <span class="count"></span>
      </label>
    `).join('');

    // Architectures
    const archList = document.getElementById('architecture-list');
    archList.innerHTML = state.filterOptions.architectures.map(a => `
      <label class="checkbox-item" data-value="${a}">
        <input type="checkbox" value="${a}" data-filter="architecture" />
        <span>${a}</span>
        <span class="count"></span>
      </label>
    `).join('');

    // Tests
    const testList = document.getElementById('test-list');
    testList.innerHTML = state.filterOptions.tests.map(t => `
      <label class="checkbox-item" data-value="${t}">
        <input type="checkbox" value="${t}" data-filter="test" />
        <span>${t}</span>
        <span class="count"></span>
      </label>
    `).join('');

    // Setup checkbox change handlers
    document.querySelectorAll('[data-filter]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });
  }

  // Update filter counts and disable/enable options
  function updateFilterCounts() {
    // Update generations
    document.querySelectorAll('#generation-list .checkbox-item').forEach(item => {
      const value = item.dataset.value;
      const count = state.filterCounts.generations[value] || 0;
      const countEl = item.querySelector('.count');
      const checkbox = item.querySelector('input');

      countEl.textContent = `(${count})`;

      // Disable if count is 0 and not currently selected
      const isSelected = state.filters.generation.includes(value);
      if (count === 0 && !isSelected) {
        item.classList.add('disabled');
        checkbox.disabled = true;
      } else {
        item.classList.remove('disabled');
        checkbox.disabled = false;
      }
    });

    // Update architectures
    document.querySelectorAll('#architecture-list .checkbox-item').forEach(item => {
      const value = item.dataset.value;
      const count = state.filterCounts.architectures[value] || 0;
      const countEl = item.querySelector('.count');
      const checkbox = item.querySelector('input');

      countEl.textContent = `(${count})`;

      const isSelected = state.filters.architecture.includes(value);
      if (count === 0 && !isSelected) {
        item.classList.add('disabled');
        checkbox.disabled = true;
      } else {
        item.classList.remove('disabled');
        checkbox.disabled = false;
      }
    });

    // Update tests
    document.querySelectorAll('#test-list .checkbox-item').forEach(item => {
      const value = item.dataset.value;
      const count = state.filterCounts.tests[value] || 0;
      const countEl = item.querySelector('.count');
      const checkbox = item.querySelector('input');

      countEl.textContent = `(${count})`;

      const isSelected = state.filters.test.includes(value);
      if (count === 0 && !isSelected) {
        item.classList.add('disabled');
        checkbox.disabled = true;
      } else {
        item.classList.remove('disabled');
        checkbox.disabled = false;
      }
    });

    // Update CPU and submitter lists with counts
    renderCpuList(document.getElementById('cpu-search').value);
    renderSubmitterList(document.getElementById('submitter-search').value);
  }

  // Render submitter list
  function renderSubmitterList(searchTerm = '') {
    const submitterList = document.getElementById('submitter-list');
    const submitterCounts = state.filterCounts.submitters || {};

    let submitterEntries = Object.entries(submitterCounts)
      .filter(([submitter]) => submitter.toLowerCase().includes(searchTerm.toLowerCase()))
      .sort((a, b) => b[1] - a[1])
      .slice(0, 30);

    if (submitterEntries.length === 0) {
      submitterList.innerHTML = '<div style="font-size: 0.75rem; color: var(--color-text-muted); padding: 0.5rem 0;">No submitters found</div>';
      return;
    }

    submitterList.innerHTML = submitterEntries.map(([submitter, count]) => `
      <label class="checkbox-item" data-value="${submitter}">
        <input type="checkbox" value="${submitter}" data-filter="submitter" ${state.filters.submitter.includes(submitter) ? 'checked' : ''} />
        <span title="${submitter}">${submitter.length > 20 ? submitter.slice(0, 20) + '...' : submitter}</span>
        <span class="count">(${count})</span>
      </label>
    `).join('');

    // Re-attach handlers
    submitterList.querySelectorAll('[data-filter]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });
  }

  // Strip Intel branding from CPU names for cleaner display
  function stripIntelBranding(cpuName) {
    return cpuName
      .replace(/Intel\(R\)\s*/gi, '')
      .replace(/Core\(TM\)\s*/gi, '')
      .replace(/\s+CPU\s*@\s*[\d.]+GHz/gi, '')
      .replace(/\s*\d{1,2}th Gen\s*/gi, '') // Remove "13th Gen" etc
      .replace(/\s+/g, ' ')
      .trim();
  }

  // Render CPU list (filtered by search and with counts)
  function renderCpuList(searchTerm = '') {
    const cpuList = document.getElementById('cpu-list');
    const cpuCounts = state.filterCounts.cpus || {};

    // Build list from counts (already filtered by current selections)
    // Search against both original and stripped names
    let cpuEntries = Object.entries(cpuCounts)
      .filter(([cpu]) => {
        const searchLower = searchTerm.toLowerCase();
        return cpu.toLowerCase().includes(searchLower) ||
               stripIntelBranding(cpu).toLowerCase().includes(searchLower);
      })
      .sort((a, b) => b[1] - a[1])
      .slice(0, 50);

    // If no filters applied, show all CPUs
    if (cpuEntries.length === 0 && Object.keys(cpuCounts).length === 0) {
      cpuList.innerHTML = '<div style="font-size: 0.75rem; color: var(--color-text-muted); padding: 0.5rem 0;">No CPUs match current filters</div>';
      return;
    }

    cpuList.innerHTML = cpuEntries.map(([cpu, count]) => {
      const displayName = stripIntelBranding(cpu);
      return `
        <label class="checkbox-item" data-value="${cpu}">
          <input type="checkbox" value="${cpu}" data-filter="cpu" ${state.filters.cpu.includes(cpu) ? 'checked' : ''} />
          <span title="${cpu}">${displayName.length > 22 ? displayName.slice(0, 22) + '...' : displayName}</span>
          <span class="count">(${count})</span>
        </label>
      `;
    }).join('');

    // Re-attach handlers
    cpuList.querySelectorAll('[data-filter]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });
  }

  // Handle filter checkbox changes
  function handleFilterChange(e) {
    const filterType = e.target.dataset.filter;
    const value = e.target.value;
    const checked = e.target.checked;

    if (checked) {
      if (!state.filters[filterType].includes(value)) {
        state.filters[filterType].push(value);
      }
    } else {
      state.filters[filterType] = state.filters[filterType].filter(v => v !== value);
    }

    state.pagination.offset = 0;
    onFiltersChanged();
  }

  // Called when filters change - updates everything
  async function onFiltersChanged() {
    await Promise.all([
      fetchFilterCounts(),
      fetchResults(),
      fetchBoxplotData(),
      fetchGenerationStats(),
      fetchCpuStats(),
    ]);
  }

  // Generation colors for multi-generation chart - high contrast palette
  const genColors = {
    6: { bg: 'rgba(220, 38, 38, 0.8)', border: 'rgb(220, 38, 38)' },      // Red
    7: { bg: 'rgba(234, 88, 12, 0.8)', border: 'rgb(234, 88, 12)' },      // Orange
    8: { bg: 'rgba(120, 120, 130, 0.6)', border: 'rgb(120, 120, 130)' },  // Gray (baseline)
    9: { bg: 'rgba(202, 138, 4, 0.8)', border: 'rgb(202, 138, 4)' },      // Amber
    10: { bg: 'rgba(22, 163, 74, 0.8)', border: 'rgb(22, 163, 74)' },     // Green
    11: { bg: 'rgba(20, 184, 166, 0.8)', border: 'rgb(20, 184, 166)' },   // Teal
    12: { bg: 'rgba(6, 182, 212, 0.8)', border: 'rgb(6, 182, 212)' },     // Cyan
    13: { bg: 'rgba(59, 130, 246, 0.85)', border: 'rgb(59, 130, 246)' },  // Blue
    14: { bg: 'rgba(168, 85, 247, 0.8)', border: 'rgb(168, 85, 247)' },   // Purple
  };

  // Fetch and display generation statistics (when generations are filtered)
  async function fetchGenerationStats() {
    const statsContainer = document.getElementById('generation-stats');
    const statsSummary = document.getElementById('gen-stats-summary');
    const statsTitle = document.getElementById('gen-stats-title');
    const statsSubtitle = document.getElementById('gen-stats-subtitle');
    // Show when one or more generations are selected
    if (state.filters.generation.length === 0) {
      statsContainer.style.display = 'none';
      // Destroy charts if exist
      if (window.genFpsChart) { window.genFpsChart.destroy(); window.genFpsChart = null; }
      if (window.genWattsChart) { window.genWattsChart.destroy(); window.genWattsChart = null; }
      if (window.genEfficiencyChart) { window.genEfficiencyChart.destroy(); window.genEfficiencyChart = null; }
      return;
    }

    const generations = state.filters.generation.join(',');

    try {
      const res = await fetch(`${API_URL}/api/results/generation-stats?generation=${generations}`);
      const data = await res.json();

      if (!data.success || !data.data || data.data.length === 0) {
        statsContainer.style.display = 'none';
        return;
      }

      statsContainer.style.display = 'block';

      // Build title based on number of generations
      const genList = data.generations.map(g => `${g}th`).join(', ');
      statsTitle.textContent = data.generations.length === 1
        ? `${genList} Gen vs 8th Gen Baseline`
        : `${genList} Gen Comparison`;

      // Build subtitle with total results
      const totalResults = data.data.reduce((sum, g) => sum + g.overall.total_results, 0);
      const totalCpus = data.data.reduce((sum, g) => sum + g.overall.unique_cpus, 0);
      statsSubtitle.textContent = `${totalResults} results from ${totalCpus} unique CPUs`;

      // Build comparison table - cleaner presentation of all metrics
      const baselineFps = data.baseline_overall?.avg_fps || 0;
      const baselineWatts = data.baseline_overall?.avg_watts;
      const baselineEff = data.baseline_overall?.fps_per_watt;

      // Helper to format % diff
      const formatDiff = (val, baseline) => {
        if (!baseline || baseline === 0 || val === null || val === undefined) return '';
        const diff = ((val - baseline) / baseline * 100);
        const cls = diff >= 0 ? 'positive' : 'negative';
        return `<span class="gen-diff ${cls}">${diff >= 0 ? '+' : ''}${diff.toFixed(0)}%</span>`;
      };

      let summaryHtml = `
        <table class="gen-comparison-table">
          <thead>
            <tr>
              <th>Generation</th>
              <th>Avg FPS</th>
              <th>Avg Watts</th>
              <th>Efficiency</th>
              <th>Results</th>
            </tr>
          </thead>
          <tbody>
      `;

      // Add row for each selected generation
      for (const genData of data.data) {
        const color = genColors[genData.generation]?.border || '#3b82f6';
        summaryHtml += `
          <tr class="gen-row" style="--gen-color: ${color}">
            <td class="gen-name">
              <span class="gen-indicator" style="background: ${color}"></span>
              <strong>${genData.generation}th Gen</strong>
              ${genData.architecture ? `<span class="gen-arch">${genData.architecture}</span>` : ''}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${genData.overall.avg_fps?.toFixed(1) || '-'}</span>
              ${formatDiff(genData.overall.avg_fps, baselineFps)}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${genData.overall.avg_watts?.toFixed(1) || '-'}</span>
              ${genData.overall.avg_watts ? formatDiff(baselineWatts, genData.overall.avg_watts) : ''}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${genData.overall.fps_per_watt?.toFixed(1) || '-'}</span>
              ${formatDiff(genData.overall.fps_per_watt, baselineEff)}
            </td>
            <td class="gen-metric-small">
              ${genData.overall.total_results} <span class="gen-muted">(${genData.overall.unique_cpus} CPUs)</span>
            </td>
          </tr>
        `;
      }

      // Add baseline row if 8th gen isn't already selected
      if (!data.generations.includes(8)) {
        summaryHtml += `
          <tr class="gen-row baseline-row">
            <td class="gen-name">
              <span class="gen-indicator" style="background: ${genColors[8].border}"></span>
              <strong>8th Gen</strong>
              <span class="gen-arch baseline-tag">Baseline</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${baselineFps?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${baselineWatts?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${baselineEff?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric-small gen-muted">Reference</td>
          </tr>
        `;
      }

      summaryHtml += `
          </tbody>
        </table>
      `;

      statsSummary.innerHTML = summaryHtml;

      // Build 3 comparison charts - FPS, Watts, Efficiency
      const testNames = data.all_tests;

      // Helper to build datasets for a given metric
      const buildDatasets = (metric) => {
        const datasets = data.data.map(genData => {
          const colors = genColors[genData.generation] || { bg: 'rgba(59, 130, 246, 0.7)', border: 'rgb(59, 130, 246)' };
          return {
            label: `${genData.generation}th Gen`,
            data: testNames.map(testName => {
              const testInfo = genData.by_test.find(t => t.test_name === testName);
              return testInfo?.[metric] || 0;
            }),
            backgroundColor: colors.bg,
            borderColor: colors.border,
            borderWidth: 1,
          };
        });

        // Add baseline dataset if 8th gen isn't already selected
        if (!data.generations.includes(8)) {
          datasets.push({
            label: '8th Gen (Baseline)',
            data: testNames.map(testName => {
              const testInfo = data.baseline_by_test.find(t => t.test_name === testName);
              return testInfo?.[metric] || 0;
            }),
            backgroundColor: genColors[8].bg,
            borderColor: genColors[8].border,
            borderWidth: 1,
          });
        }
        return datasets;
      };

      // Helper to create a chart
      const createComparisonChart = (canvasId, title, yLabel, datasets, baselineData, metric) => {
        const canvas = document.getElementById(canvasId);
        return new Chart(canvas, {
          type: 'bar',
          data: { labels: testNames, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
                labels: { color: '#f1f5f9', font: { size: 11 } },
              },
              title: {
                display: true,
                text: title,
                color: '#f1f5f9',
                font: { size: 13, weight: '600' },
              },
              tooltip: {
                callbacks: {
                  afterLabel: (context) => {
                    const gen = parseInt(context.dataset.label);
                    if (gen !== 8 && baselineData) {
                      const testName = testNames[context.dataIndex];
                      const baselineTest = baselineData.find(t => t.test_name === testName);
                      const baseVal = baselineTest?.[metric];
                      if (baseVal && baseVal > 0) {
                        // For watts, lower is better so invert the comparison
                        const diff = metric === 'avg_watts'
                          ? ((baseVal - context.raw) / baseVal * 100)
                          : ((context.raw - baseVal) / baseVal * 100);
                        return `${diff >= 0 ? '+' : ''}${diff.toFixed(0)}% vs 8th Gen`;
                      }
                    }
                    return '';
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#94a3b8', font: { size: 10 } },
                grid: { color: '#334155' },
              },
              y: {
                ticks: { color: '#94a3b8' },
                grid: { color: '#334155' },
                title: { display: true, text: yLabel, color: '#94a3b8' },
              },
            },
          },
        });
      };

      // Destroy existing charts
      if (window.genFpsChart) window.genFpsChart.destroy();
      if (window.genWattsChart) window.genWattsChart.destroy();
      if (window.genEfficiencyChart) window.genEfficiencyChart.destroy();

      // Create 3 charts
      window.genFpsChart = createComparisonChart(
        'gen-fps-chart',
        'Average FPS by Test Type',
        'Frames per Second',
        buildDatasets('avg_fps'),
        data.baseline_by_test,
        'avg_fps'
      );

      window.genWattsChart = createComparisonChart(
        'gen-watts-chart',
        'Average Power Usage by Test Type',
        'Watts',
        buildDatasets('avg_watts'),
        data.baseline_by_test,
        'avg_watts'
      );

      window.genEfficiencyChart = createComparisonChart(
        'gen-efficiency-chart',
        'Efficiency (FPS per Watt) by Test Type',
        'FPS/Watt',
        buildDatasets('fps_per_watt'),
        data.baseline_by_test,
        'fps_per_watt'
      );
    } catch (e) {
      console.error('Failed to fetch generation stats:', e);
      statsContainer.style.display = 'none';
    }
  }

  // CPU colors for multi-CPU chart - distinct palette
  const cpuColors = [
    { bg: 'rgba(34, 197, 94, 0.8)', border: 'rgb(34, 197, 94)' },      // Green
    { bg: 'rgba(59, 130, 246, 0.8)', border: 'rgb(59, 130, 246)' },    // Blue
    { bg: 'rgba(168, 85, 247, 0.8)', border: 'rgb(168, 85, 247)' },    // Purple
    { bg: 'rgba(234, 88, 12, 0.8)', border: 'rgb(234, 88, 12)' },      // Orange
    { bg: 'rgba(6, 182, 212, 0.8)', border: 'rgb(6, 182, 212)' },      // Cyan
    { bg: 'rgba(236, 72, 153, 0.8)', border: 'rgb(236, 72, 153)' },    // Pink
    { bg: 'rgba(202, 138, 4, 0.8)', border: 'rgb(202, 138, 4)' },      // Amber
    { bg: 'rgba(20, 184, 166, 0.8)', border: 'rgb(20, 184, 166)' },    // Teal
  ];

  // Fetch and display CPU statistics (when CPUs are filtered)
  async function fetchCpuStats() {
    const statsContainer = document.getElementById('cpu-stats');
    const statsSummary = document.getElementById('cpu-stats-summary');
    const statsTitle = document.getElementById('cpu-stats-title');
    const statsSubtitle = document.getElementById('cpu-stats-subtitle');

    // Show when one or more CPUs are selected
    if (state.filters.cpu.length === 0) {
      statsContainer.style.display = 'none';
      // Destroy charts if exist
      if (window.cpuFpsChart) { window.cpuFpsChart.destroy(); window.cpuFpsChart = null; }
      if (window.cpuWattsChart) { window.cpuWattsChart.destroy(); window.cpuWattsChart = null; }
      if (window.cpuEfficiencyChart) { window.cpuEfficiencyChart.destroy(); window.cpuEfficiencyChart = null; }
      return;
    }

    const cpus = state.filters.cpu.join('||');

    try {
      const res = await fetch(`${API_URL}/api/results/cpu-stats?cpu=${encodeURIComponent(cpus)}`);
      const data = await res.json();

      if (!data.success || !data.data || data.data.length === 0) {
        statsContainer.style.display = 'none';
        return;
      }

      statsContainer.style.display = 'block';

      // Build title
      const cpuCount = data.data.length;
      statsTitle.textContent = cpuCount === 1
        ? `CPU: ${stripIntelBranding(data.data[0].cpu_raw)}`
        : `Comparing ${cpuCount} CPUs`;

      // Build subtitle with total results
      const totalResults = data.data.reduce((sum, c) => sum + c.overall.total_results, 0);
      statsSubtitle.textContent = `${totalResults} benchmark results`;

      // Build comparison table
      let summaryHtml = `
        <table class="gen-comparison-table">
          <thead>
            <tr>
              <th>CPU</th>
              <th>Architecture</th>
              <th>Avg FPS</th>
              <th>Avg Watts</th>
              <th>Efficiency</th>
              <th>Results</th>
            </tr>
          </thead>
          <tbody>
      `;

      // Add row for each CPU
      data.data.forEach((cpuData, idx) => {
        const color = cpuColors[idx % cpuColors.length].border;
        const displayName = stripIntelBranding(cpuData.cpu_raw);
        summaryHtml += `
          <tr class="gen-row" style="--gen-color: ${color}">
            <td class="gen-name">
              <span class="gen-indicator" style="background: ${color}"></span>
              <strong title="${cpuData.cpu_raw}">${displayName.length > 30 ? displayName.slice(0, 30) + '...' : displayName}</strong>
            </td>
            <td>
              ${cpuData.architecture ? `<span class="gen-arch">${cpuData.architecture}</span>` : '-'}
              ${cpuData.cpu_generation ? `<span class="gen-arch">${cpuData.cpu_generation}th Gen</span>` : ''}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${cpuData.overall.avg_fps?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${cpuData.overall.avg_watts?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${cpuData.overall.fps_per_watt?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric-small">
              ${cpuData.overall.total_results}
            </td>
          </tr>
        `;
      });

      summaryHtml += `
          </tbody>
        </table>
      `;

      statsSummary.innerHTML = summaryHtml;

      // Build 3 comparison charts - FPS, Watts, Efficiency
      const testNames = data.all_tests;

      // Helper to build datasets for a given metric
      const buildDatasets = (metric) => {
        return data.data.map((cpuData, idx) => {
          const colors = cpuColors[idx % cpuColors.length];
          const displayName = stripIntelBranding(cpuData.cpu_raw);
          return {
            label: displayName.length > 20 ? displayName.slice(0, 20) + '...' : displayName,
            data: testNames.map(testName => {
              const testInfo = cpuData.by_test.find(t => t.test_name === testName);
              return testInfo?.[metric] || 0;
            }),
            backgroundColor: colors.bg,
            borderColor: colors.border,
            borderWidth: 1,
          };
        });
      };

      // Helper to create a chart
      const createCpuComparisonChart = (canvasId, title, yLabel, datasets) => {
        const canvas = document.getElementById(canvasId);
        return new Chart(canvas, {
          type: 'bar',
          data: { labels: testNames, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
                labels: { color: '#f1f5f9', font: { size: 11 } },
              },
              title: {
                display: true,
                text: title,
                color: '#f1f5f9',
                font: { size: 13, weight: '600' },
              },
            },
            scales: {
              x: {
                ticks: { color: '#94a3b8', font: { size: 10 } },
                grid: { color: '#334155' },
              },
              y: {
                ticks: { color: '#94a3b8' },
                grid: { color: '#334155' },
                title: { display: true, text: yLabel, color: '#94a3b8' },
              },
            },
          },
        });
      };

      // Destroy existing charts
      if (window.cpuFpsChart) window.cpuFpsChart.destroy();
      if (window.cpuWattsChart) window.cpuWattsChart.destroy();
      if (window.cpuEfficiencyChart) window.cpuEfficiencyChart.destroy();

      // Create 3 charts
      window.cpuFpsChart = createCpuComparisonChart(
        'cpu-fps-chart',
        'Average FPS by Test Type',
        'Frames per Second',
        buildDatasets('avg_fps')
      );

      window.cpuWattsChart = createCpuComparisonChart(
        'cpu-watts-chart',
        'Average Power Usage by Test Type',
        'Watts',
        buildDatasets('avg_watts')
      );

      window.cpuEfficiencyChart = createCpuComparisonChart(
        'cpu-efficiency-chart',
        'Efficiency (FPS per Watt) by Test Type',
        'FPS/Watt',
        buildDatasets('fps_per_watt')
      );
    } catch (e) {
      console.error('Failed to fetch CPU stats:', e);
      statsContainer.style.display = 'none';
    }
  }

  // Toggle generation filter (called from chart click)
  function toggleGenerationFilter(generation) {
    const genStr = String(generation);
    const checkbox = document.querySelector(`[data-filter="generation"][value="${genStr}"]`);

    if (state.filters.generation.includes(genStr)) {
      state.filters.generation = state.filters.generation.filter(g => g !== genStr);
      if (checkbox) checkbox.checked = false;
    } else {
      state.filters.generation.push(genStr);
      if (checkbox) checkbox.checked = true;
    }

    state.pagination.offset = 0;
    onFiltersChanged();
  }

  // Make it globally accessible for chart click handler
  window.toggleGenerationFilter = toggleGenerationFilter;

  // Toggle architecture filter (called from chart click for Arc)
  function toggleArchitectureFilter(architecture) {
    const archStr = String(architecture);
    const checkbox = document.querySelector(`[data-filter="architecture"][value="${archStr}"]`);

    if (state.filters.architecture.includes(archStr)) {
      state.filters.architecture = state.filters.architecture.filter(a => a !== archStr);
      if (checkbox) checkbox.checked = false;
    } else {
      state.filters.architecture.push(archStr);
      if (checkbox) checkbox.checked = true;
    }

    state.pagination.offset = 0;
    onFiltersChanged();
  }

  // Make it globally accessible for chart click handler
  window.toggleArchitectureFilter = toggleArchitectureFilter;

  // Fetch boxplot data
  // NOTE: Charts always show all generations + Arc, regardless of filters
  // Architecture filter only affects the results table, not the charts
  async function fetchBoxplotData() {
    const params = new URLSearchParams();
    if (state.filters.test.length > 0) {
      params.set('test', state.filters.test.join(','));
    }
    // Don't filter charts by generation or architecture - they always show all data
    // The filters only affect the results table

    const metrics = ['avg_fps', 'avg_watts', 'fps_per_watt'];

    for (const metric of metrics) {
      try {
        // Fetch CPU generation data (unfiltered by generation/architecture)
        const res = await fetch(`${API_URL}/api/stats/boxplot?metric=${metric}&group_by=cpu_generation&${params}`);
        const data = await res.json();

        // Also fetch Arc GPU data by architecture
        const arcParams = new URLSearchParams(params);
        arcParams.set('architecture', 'Alchemist,Battlemage');
        const arcRes = await fetch(`${API_URL}/api/stats/boxplot?metric=${metric}&group_by=architecture&${arcParams}`);
        const arcData = await arcRes.json();

        if (data.success) {
          let boxplotData = data.boxplot;

          // Merge Arc data with "Arc" label (combining Alchemist and Battlemage)
          if (arcData.success && arcData.boxplot.length > 0) {
            // Rename Arc architectures to just "Arc" for display
            const arcResults = arcData.boxplot.map(d => ({
              ...d,
              group: 'Arc'
            }));
            boxplotData = [...boxplotData, ...arcResults];
          }

          state.boxplotData[metric] = boxplotData;
          updateChart(metric);
        }
      } catch (e) {
        console.error(`Failed to fetch ${metric} boxplot:`, e);
      }
    }
  }

  // Update Chart.js chart
  function updateChart(metric) {
    const chartId = {
      'avg_fps': 'fps-chart',
      'avg_watts': 'watts-chart',
      'fps_per_watt': 'efficiency-chart',
    }[metric];

    const canvas = document.getElementById(chartId);
    const boxplotData = state.boxplotData[metric] || [];

    // Group by generation and sort (put "Arc" at the end)
    // Filter out generations < 6
    const allGroups = [...new Set(boxplotData.map(d => d.group))];
    const numericGroups = allGroups
      .filter(g => !isNaN(parseInt(g)) && parseInt(g) >= 6)
      .sort((a, b) => parseInt(a) - parseInt(b));
    const nonNumericGroups = allGroups.filter(g => isNaN(parseInt(g))).sort();
    const generations = [...numericGroups, ...nonNumericGroups];
    const tests = [...new Set(boxplotData.map(d => d.test))];

    // Build datasets for Chart.js
    const datasets = tests.map(test => {
      const testData = boxplotData.filter(d => d.test === test);
      const colors = testColors[test] || { bg: 'rgba(148, 163, 184, 0.6)', border: 'rgb(148, 163, 184)' };

      return {
        label: test,
        data: generations.map(gen => {
          const point = testData.find(d => d.group === gen);
          return point ? point.median : null;
        }),
        backgroundColor: colors.bg,
        borderColor: colors.border,
        borderWidth: 1,
      };
    });

    // Highlight selected generations
    const selectedGens = state.filters.generation;

    // Destroy existing chart if any
    if (window.charts && window.charts[chartId]) {
      window.charts[chartId].destroy();
    }

    if (!window.charts) window.charts = {};

    window.charts[chartId] = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: generations.map(g => isNaN(parseInt(g)) ? g : `Gen ${g}`),
        datasets,
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        onClick: (event, elements) => {
          if (elements.length > 0) {
            const index = elements[0].index;
            const group = generations[index];
            const isNumeric = !isNaN(parseInt(group));
            if (isNumeric) {
              window.toggleGenerationFilter(group);
            } else if (group === 'Arc') {
              window.toggleArchitectureFilter('Alchemist');
              window.toggleArchitectureFilter('Battlemage');
            }
          }
        },
        plugins: {
          legend: {
            position: 'top',
            labels: { color: '#94a3b8', font: { size: 11 } },
          },
          tooltip: {
            callbacks: {
              title: (items) => {
                const gen = generations[items[0].dataIndex];
                const isNumeric = !isNaN(parseInt(gen));
                const label = isNumeric ? `Gen ${gen}` : gen;
                const isSelected = isNumeric
                  ? selectedGens.includes(String(gen))
                  : (gen === 'Arc' && (state.filters.architecture.includes('Alchemist') || state.filters.architecture.includes('Battlemage')));
                const isClickable = isNumeric || gen === 'Arc';
                return `${label}${isSelected ? ' (filtered)' : ''}${isClickable ? ' - Click to toggle' : ''}`;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              color: (ctx) => {
                const gen = generations[ctx.index];
                const isNumeric = !isNaN(parseInt(gen));
                const isSelected = isNumeric
                  ? selectedGens.includes(String(gen))
                  : (gen === 'Arc' && (state.filters.architecture.includes('Alchemist') || state.filters.architecture.includes('Battlemage')));
                return isSelected ? '#3b82f6' : '#94a3b8';
              },
              font: (ctx) => {
                const gen = generations[ctx.index];
                const isNumeric = !isNaN(parseInt(gen));
                const isSelected = isNumeric
                  ? selectedGens.includes(String(gen))
                  : (gen === 'Arc' && (state.filters.architecture.includes('Alchemist') || state.filters.architecture.includes('Battlemage')));
                return { weight: isSelected ? 'bold' : 'normal' };
              }
            },
            grid: { color: '#334155' },
          },
          y: {
            ticks: { color: '#94a3b8' },
            grid: { color: '#334155' },
            title: {
              display: true,
              text: canvas.dataset.ylabel,
              color: '#94a3b8',
            },
          },
        },
      },
    });
  }

  // Fetch CPU scores
  async function fetchCpuScores() {
    try {
      const res = await fetch(`${API_URL}/api/scores/for-results`);
      const data = await res.json();
      if (data.success) {
        state.cpuScores = data.scores;
      }
    } catch (e) {
      console.error('Failed to fetch CPU scores:', e);
    }
  }

  // Fetch results table
  async function fetchResults() {
    const params = new URLSearchParams();

    if (state.filters.generation.length > 0) {
      params.set('generation', state.filters.generation.join(','));
    }
    if (state.filters.architecture.length > 0) {
      params.set('architecture', state.filters.architecture.join(','));
    }
    if (state.filters.test.length > 0) {
      params.set('test', state.filters.test.join(','));
    }
    if (state.filters.cpu.length > 0) {
      params.set('cpu', state.filters.cpu.join('||'));
    }
    if (state.filters.submitter.length > 0) {
      params.set('submitter_id', state.filters.submitter[0]); // Single submitter filter
    }

    // Score sorting is done client-side since scores aren't in the database
    const sortingByScore = state.sort.column === 'score';
    if (sortingByScore) {
      // For score sorting, fetch more results to sort client-side, then paginate
      params.set('sort', 'submitted_at');
      params.set('order', 'desc');
      params.set('limit', '1000'); // Fetch more for client-side sorting
      params.set('offset', '0');
    } else {
      params.set('sort', state.sort.column);
      params.set('order', state.sort.order);
      params.set('limit', state.pagination.limit);
      params.set('offset', state.pagination.offset);
    }

    try {
      const res = await fetch(`${API_URL}/api/results?${params}`);
      const data = await res.json();

      if (data.success) {
        let results = data.results;
        let total = data.total;

        // Client-side score sorting
        if (sortingByScore) {
          results = results.sort((a, b) => {
            const scoreA = state.cpuScores[a.cpu_raw] ?? -1;
            const scoreB = state.cpuScores[b.cpu_raw] ?? -1;
            return state.sort.order === 'desc' ? scoreB - scoreA : scoreA - scoreB;
          });

          // Apply pagination after sorting
          const start = state.pagination.offset;
          const end = start + state.pagination.limit;
          results = results.slice(start, end);
        }

        renderResults(results, total, state.cpuScores);

        // Update filtered count
        document.getElementById('filtered-results').textContent = total.toLocaleString();

        // Update pagination
        const currentPage = Math.floor(state.pagination.offset / state.pagination.limit) + 1;
        const totalPages = Math.ceil(total / state.pagination.limit);

        document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages}`;
        document.getElementById('prev-page').disabled = state.pagination.offset === 0;
        document.getElementById('next-page').disabled = state.pagination.offset + state.pagination.limit >= total;
      }
    } catch (e) {
      console.error('Failed to fetch results:', e);
    }
  }

  // Render results table
  function renderResults(results, total, cpuScores = {}) {
    document.getElementById('results-count').textContent = `(${total.toLocaleString()} results)`;

    const tbody = document.getElementById('results-body');

    if (results.length === 0) {
      tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 2rem;">No results found</td></tr>';
      return;
    }

    tbody.innerHTML = results.map(r => {
      const testClass = r.test_name.includes('cpu') ? 'cpu' : r.test_name.includes('hevc') ? 'hevc' : 'h264';
      const date = new Date(r.submitted_at).toLocaleDateString();
      const displayCpu = stripIntelBranding(r.cpu_raw);
      const score = cpuScores[r.cpu_raw];
      const scoreClass = score >= 70 ? 'score-high' : score >= 40 ? 'score-mid' : 'score-low';

      return `
        <tr>
          <td class="cpu-cell" title="${r.cpu_raw}">${displayCpu}</td>
          <td>${r.architecture || '-'}</td>
          <td><span class="test-badge ${testClass}">${r.test_name}</span></td>
          <td class="numeric">${r.avg_fps?.toFixed(1) || '-'}</td>
          <td class="numeric">${r.avg_watts?.toFixed(1) || '-'}</td>
          <td class="numeric">${r.fps_per_watt?.toFixed(2) || '-'}</td>
          <td class="numeric">${r.avg_speed ? r.avg_speed.toFixed(2) + 'x' : '-'}</td>
          <td class="numeric">${score !== undefined ? `<span class="score-badge ${scoreClass}">${score}</span>` : '-'}</td>
          <td>${date}</td>
        </tr>
      `;
    }).join('');
  }

  // Clear all filters
  function clearFilters() {
    state.filters = { generation: [], architecture: [], test: [], cpu: [], submitter: [] };
    state.pagination.offset = 0;

    // Uncheck all checkboxes
    document.querySelectorAll('[data-filter]').forEach(cb => {
      cb.checked = false;
    });

    // Clear search inputs
    document.getElementById('cpu-search').value = '';
    document.getElementById('submitter-search').value = '';

    onFiltersChanged();
  }

  // Event handlers setup
  function setupEventHandlers() {
    // Clear filters button
    document.getElementById('clear-filters').addEventListener('click', clearFilters);

    // Submitter search
    document.getElementById('submitter-search').addEventListener('input', (e) => {
      renderSubmitterList(e.target.value);
    });

    // CPU search
    document.getElementById('cpu-search').addEventListener('input', (e) => {
      renderCpuList(e.target.value);
    });

    // Sort columns
    document.querySelectorAll('th[data-sort]').forEach(th => {
      th.addEventListener('click', () => {
        const column = th.dataset.sort;

        if (state.sort.column === column) {
          state.sort.order = state.sort.order === 'asc' ? 'desc' : 'asc';
        } else {
          state.sort.column = column;
          state.sort.order = 'desc';
        }

        // Update UI
        document.querySelectorAll('th[data-sort]').forEach(t => t.classList.remove('sorted-asc', 'sorted-desc'));
        th.classList.add(state.sort.order === 'asc' ? 'sorted-asc' : 'sorted-desc');

        fetchResults();
      });
    });

    // Pagination
    document.getElementById('prev-page').addEventListener('click', () => {
      state.pagination.offset = Math.max(0, state.pagination.offset - state.pagination.limit);
      fetchResults();
    });

    document.getElementById('next-page').addEventListener('click', () => {
      state.pagination.offset += state.pagination.limit;
      fetchResults();
    });

    // Results limit
    document.getElementById('results-limit').addEventListener('change', (e) => {
      state.pagination.limit = parseInt(e.target.value);
      state.pagination.offset = 0;
      fetchResults();
    });

    // Info banner toggle
    document.getElementById('hide-banner').addEventListener('click', () => {
      document.getElementById('info-banner').style.display = 'none';
      document.getElementById('show-banner').style.display = 'flex';
      localStorage.setItem('quicksync-banner-hidden', 'true');
    });

    document.getElementById('show-banner').addEventListener('click', () => {
      document.getElementById('info-banner').style.display = 'block';
      document.getElementById('show-banner').style.display = 'none';
      localStorage.removeItem('quicksync-banner-hidden');
    });

    // Check if banner was previously hidden
    if (localStorage.getItem('quicksync-banner-hidden') === 'true') {
      document.getElementById('info-banner').style.display = 'none';
      document.getElementById('show-banner').style.display = 'flex';
    }
  }

  // Initialize
  async function init() {
    await Promise.all([
      fetchSummary(),
      fetchFilters(),
      fetchCpuScores(),
    ]);

    // Fetch initial filter counts (no filters applied)
    await fetchFilterCounts();

    await fetchResults();
    await fetchBoxplotData();

    setupEventHandlers();
  }

  // Load Chart.js and initialize
  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
  script.onload = init;
  document.head.appendChild(script);
})();</script>