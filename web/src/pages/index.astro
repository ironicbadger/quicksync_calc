---
import Layout from '../layouts/Layout.astro';
import ResultsTable from '../components/ResultsTable.astro';
import BoxplotChart from '../components/charts/BoxplotChart.astro';

// API URL for submission endpoints only (data now loaded from R2)
const API_URL = import.meta.env.PUBLIC_API_URL || 'https://quicksync-api.ktz.me';
// R2 public URL for benchmark data
// For local dev with test data: change to '/test-data.json'
const DATA_URL = 'https://pub-c66d7559b64a430ca682a4bd624f04d8.r2.dev/benchmarks.json';
---

<Layout title="QuickSync Benchmarks - Intel Quick Sync Video Performance">
  <!-- Info Banner (collapsible) -->
  <div id="info-banner" class="info-banner">
    <div class="info-banner-content">
      <div class="info-banner-main">
        <div class="info-section">
          <h2>Intel Quick Sync Video Benchmarks</h2>
          <p>Community-driven database of hardware transcoding performance. Compare FPS, power usage, and efficiency across Intel CPU generations for Plex/Jellyfin transcoding.</p><br />
          <p>Brought to you by <a href="https://github.com/ironicbadger" target="_blank" rel="noopener noreferrer">ironicbadger</a> and <a href="https://github.com/cptmorgan-rh" target="_blank" rel="noopener noreferrer">cptmorgan</a>.</p>
        </div>
        <div class="info-section">
          <h3>How to Use</h3>
          <ul>
            <li><strong>Filter:</strong> Use the sidebar to filter by CPU model, generation, or test type</li>
            <li><strong>Click charts:</strong> Click any bar to filter by that generation</li>
            <li><strong>Compare:</strong> Select a generation to see detailed stats vs 8th Gen baseline</li>
          </ul>
        </div>
        <div class="info-section">
          <h3>Submit Your Results</h3>
          <pre><code>git clone https://github.com/ironicbadger/quicksync_calc.git
cd quicksync_calc
./quicksync-benchmark.sh</code></pre>
          <p class="info-note">After benchmarks complete, you'll get a link to verify and submit your results. Requires Docker + Intel CPU with Quick Sync. <a href="/about">Full instructions</a></p>
        </div>
      </div>
      <button id="hide-banner" class="hide-banner-btn" title="Hide this banner">
        <span class="hide-icon">×</span>
      </button>
    </div>
  </div>

  <!-- Show banner button (when hidden) -->
  <button id="show-banner" class="show-banner-btn" style="display: none;">
    <span>?</span> Info & Submit
  </button>

  <div class="dashboard-layout">
    <!-- Left Sidebar: Filters -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h2>Filters</h2>
        <button id="clear-filters" class="btn-link">Clear All</button>
      </div>

      <!-- Submitter ID -->
      <div class="filter-section">
        <h3>Submitter ID</h3>
        <input
          type="text"
          id="submitter-search"
          placeholder="Search submitters..."
          class="search-input"
        />
        <div id="submitter-list" class="checkbox-list submitter-list">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- CPU Search -->
      <div class="filter-section">
        <h3>CPU Model</h3>
        <input
          type="text"
          id="cpu-search"
          placeholder="Search CPUs..."
          class="search-input"
        />
        <div id="cpu-list" class="checkbox-list cpu-list">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- CPU Generation -->
      <div class="filter-section">
        <h3>Generation</h3>
        <div id="generation-list" class="checkbox-list">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Architecture -->
      <div class="filter-section">
        <h3>Architecture</h3>
        <div id="architecture-list" class="checkbox-list">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Test Type -->
      <div class="filter-section">
        <h3>Test Type</h3>
        <div id="test-list" class="checkbox-list">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- ECC Support -->
      <div class="filter-section">
        <h3>ECC Support</h3>
        <div id="ecc-list" class="checkbox-list">
          <label class="checkbox-item" data-value="yes">
            <input type="checkbox" value="yes" data-filter="ecc" />
            <span>ECC Supported</span>
            <span class="count" id="ecc-yes-count"></span>
          </label>
          <label class="checkbox-item" data-value="no">
            <input type="checkbox" value="no" data-filter="ecc" />
            <span>No ECC</span>
            <span class="count" id="ecc-no-count"></span>
          </label>
        </div>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Summary Stats -->
      <div class="summary-cards">
        <div class="card summary-card">
          <div class="summary-value" id="total-results">-</div>
          <div class="summary-label">Total Results</div>
        </div>
        <div class="card summary-card">
          <div class="summary-value" id="unique-cpus">-</div>
          <div class="summary-label">Unique CPUs</div>
        </div>
        <div class="card summary-card">
          <div class="summary-value" id="filtered-results">-</div>
          <div class="summary-label">Filtered Results</div>
        </div>
        <div class="card summary-card">
          <div class="summary-value" id="architectures-count">-</div>
          <div class="summary-label">Architectures</div>
        </div>
      </div>

      <!-- Charts Grid -->
      <div class="charts-grid">
        <BoxplotChart id="fps-chart" title="Average FPS by Generation" metric="avg_fps" yLabel="Frames per Second" />
        <BoxplotChart id="watts-chart" title="Power Usage by Generation" metric="avg_watts" yLabel="Watts" />
        <BoxplotChart id="efficiency-chart" title="Efficiency (FPS/Watt) by Generation" metric="fps_per_watt" yLabel="FPS per Watt" />
      </div>

      <!-- Generation Stats (shown when single generation selected) -->
      <div id="generation-stats" class="generation-stats" style="display: none;">
        <div class="gen-stats-header">
          <h3 id="gen-stats-title">Generation Statistics</h3>
          <span id="gen-stats-subtitle" class="gen-stats-subtitle"></span>
        </div>
        <div class="gen-stats-content">
          <!-- Summary metrics row -->
          <div id="gen-stats-summary" class="gen-stats-summary">
            <!-- Populated by JS -->
          </div>
          <!-- Comparison charts - stacked -->
          <div class="gen-stats-charts">
            <div class="gen-stats-chart-container">
              <canvas id="gen-fps-chart"></canvas>
            </div>
            <div class="gen-stats-chart-container">
              <canvas id="gen-watts-chart"></canvas>
            </div>
            <div class="gen-stats-chart-container">
              <canvas id="gen-efficiency-chart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- CPU Stats (shown when CPU is selected) -->
      <div id="cpu-stats" class="generation-stats cpu-stats-panel" style="display: none;">
        <div class="gen-stats-header">
          <h3 id="cpu-stats-title">CPU Statistics</h3>
          <span id="cpu-stats-subtitle" class="gen-stats-subtitle"></span>
        </div>
        <div class="gen-stats-content">
          <!-- Summary metrics row -->
          <div id="cpu-stats-summary" class="gen-stats-summary">
            <!-- Populated by JS -->
          </div>
          <!-- Comparison charts - stacked -->
          <div class="gen-stats-charts">
            <div class="gen-stats-chart-container">
              <canvas id="cpu-fps-chart"></canvas>
            </div>
            <div class="gen-stats-chart-container">
              <canvas id="cpu-watts-chart"></canvas>
            </div>
            <div class="gen-stats-chart-container">
              <canvas id="cpu-efficiency-chart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Concurrency Leaderboard (shown when there's concurrency data) -->
      <div id="concurrency-section" class="concurrency-section" style="display: none;">
        <div class="section-header">
          <h3>Concurrency Leaderboard</h3>
          <span class="section-subtitle">Maximum simultaneous streams at realtime speed (≥1.0x)</span>
        </div>
        <div class="concurrency-tables">
          <div class="concurrency-table-wrapper">
            <h4>H.264 1080p</h4>
            <table id="h264-concurrency-table" class="concurrency-table">
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>CPU</th>
                  <th>Architecture</th>
                  <th>Max Streams</th>
                </tr>
              </thead>
              <tbody>
                <!-- Populated by JS -->
              </tbody>
            </table>
          </div>
          <div class="concurrency-table-wrapper">
            <h4>HEVC 1080p</h4>
            <table id="hevc-concurrency-table" class="concurrency-table">
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>CPU</th>
                  <th>Architecture</th>
                  <th>Max Streams</th>
                </tr>
              </thead>
              <tbody>
                <!-- Populated by JS -->
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Results Table -->
      <ResultsTable />
    </main>
  </div>
</Layout>

<style is:global>
  /* Info Banner Styles */
  .info-banner {
    max-width: 1600px;
    margin: 0 auto 1.5rem;
    padding: 0 1rem;
  }

  .info-banner-content {
    background: linear-gradient(135deg, var(--color-bg-secondary) 0%, rgba(59, 130, 246, 0.08) 100%);
    border: 1px solid var(--color-border);
    border-radius: 0.75rem;
    padding: 1.25rem 1.5rem;
    position: relative;
  }

  .info-banner-main {
    display: grid;
    grid-template-columns: 1.2fr 1fr 1.3fr;
    gap: 2rem;
  }

  .info-section h2 {
    font-size: 1.125rem;
    font-weight: 700;
    color: var(--color-accent);
    margin: 0 0 0.5rem;
  }

  .info-section h3 {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--color-text);
    margin: 0 0 0.5rem;
  }

  .info-section p {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    margin: 0;
    line-height: 1.5;
  }

  .info-section ul {
    margin: 0;
    padding-left: 1.25rem;
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    line-height: 1.6;
  }

  .info-section ul li {
    margin-bottom: 0.25rem;
  }

  .info-section pre {
    background: var(--color-bg);
    padding: 0.625rem 0.875rem;
    border-radius: 0.375rem;
    font-size: 0.75rem;
    overflow-x: auto;
    margin: 0;
    border: 1px solid var(--color-border);
  }

  .info-section code {
    font-family: var(--font-mono);
    background: none;
    padding: 0;
    font-size: inherit;
  }

  .info-note {
    margin-top: 0.5rem !important;
    font-size: 0.75rem !important;
  }

  .hide-banner-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    background: transparent;
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    color: var(--color-text-muted);
    width: 1.75rem;
    height: 1.75rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s;
  }

  .hide-banner-btn:hover {
    background: var(--color-bg);
    color: var(--color-text);
    border-color: var(--color-text-muted);
  }

  .hide-icon {
    font-size: 1.25rem;
    line-height: 1;
  }

  .show-banner-btn {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    background: var(--color-accent);
    color: white;
    border: none;
    border-radius: 0.5rem;
    padding: 0.625rem 1rem;
    font-size: 0.8125rem;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    transition: all 0.15s;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .show-banner-btn:hover {
    background: var(--color-accent-hover);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
  }

  .show-banner-btn span:first-child {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 1.25rem;
    height: 1.25rem;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    font-size: 0.875rem;
  }

  @media (max-width: 1000px) {
    .info-banner-main {
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .info-section pre {
      font-size: 0.6875rem;
    }
  }

  /* Dashboard Layout */
  .dashboard-layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: 1.5rem;
    max-width: 1600px;
    margin: 0 auto;
    padding: 0 1rem;
  }

  .sidebar {
    position: sticky;
    top: 1rem;
    height: fit-content;
    max-height: calc(100vh - 2rem);
    overflow-y: auto;
    background-color: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 1rem;
  }

  .sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--color-border);
  }

  .sidebar-header h2 {
    font-size: 1rem;
    font-weight: 600;
  }

  .btn-link {
    background: none;
    border: none;
    color: var(--color-accent);
    font-size: 0.75rem;
    cursor: pointer;
  }

  .btn-link:hover {
    text-decoration: underline;
  }

  .filter-section {
    margin-bottom: 1.25rem;
  }

  .filter-section h3 {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.5rem;
  }

  .search-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    background-color: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    color: var(--color-text);
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
  }

  .search-input:focus {
    outline: none;
    border-color: var(--color-accent);
  }

  .checkbox-list {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    max-height: 200px;
    overflow-y: auto;
  }

  .cpu-list {
    max-height: 150px;
  }

  .submitter-list {
    max-height: 120px;
  }

  .checkbox-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0;
    cursor: pointer;
    font-size: 0.875rem;
    transition: opacity 0.15s;
  }

  .checkbox-item:hover {
    color: var(--color-accent);
  }

  .checkbox-item.disabled {
    opacity: 0.35;
    cursor: not-allowed;
  }

  .checkbox-item.disabled:hover {
    color: inherit;
  }

  .checkbox-item input[type="checkbox"] {
    width: 1rem;
    height: 1rem;
    accent-color: var(--color-accent);
    cursor: pointer;
  }

  .checkbox-item.disabled input[type="checkbox"] {
    cursor: not-allowed;
  }

  .checkbox-item .count {
    margin-left: auto;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    min-width: 2.5rem;
    text-align: right;
  }

  .main-content {
    min-width: 0;
  }

  .summary-cards {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .summary-card {
    text-align: center;
    padding: 1.25rem;
  }

  .summary-value {
    font-size: 1.75rem;
    font-weight: 700;
    color: var(--color-accent);
    font-family: var(--font-mono);
  }

  .summary-label {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-top: 0.25rem;
  }

  .charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 1.5rem;
    margin-bottom: 1.5rem;
  }

  /* Concurrency Section Styles */
  .concurrency-section {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
  }

  .concurrency-section .section-header {
    display: flex;
    align-items: baseline;
    gap: 1rem;
    margin-bottom: 1.25rem;
  }

  .concurrency-section .section-header h3 {
    font-size: 1.125rem;
    font-weight: 700;
    color: var(--color-text);
    margin: 0;
  }

  .concurrency-section .section-subtitle {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
  }

  .concurrency-tables {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
  }

  .concurrency-table-wrapper h4 {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--color-text);
    margin: 0 0 0.75rem;
  }

  .concurrency-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.8125rem;
  }

  .concurrency-table th {
    text-align: left;
    padding: 0.5rem 0.75rem;
    font-weight: 600;
    color: var(--color-text-muted);
    border-bottom: 1px solid var(--color-border);
    background: var(--color-bg);
  }

  .concurrency-table td {
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid var(--color-border);
    color: var(--color-text);
  }

  .concurrency-table tr:hover td {
    background: var(--color-bg);
  }

  .concurrency-table .rank-cell {
    font-weight: 700;
    color: var(--color-accent);
    width: 50px;
  }

  .concurrency-table .streams-cell {
    font-weight: 600;
    color: var(--color-success, #10b981);
    text-align: right;
  }

  .concurrency-table .cpu-cell {
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .generation-stats {
    background: linear-gradient(135deg, var(--color-bg-secondary) 0%, rgba(59, 130, 246, 0.05) 100%);
    border: 2px solid var(--color-accent);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 4px 24px rgba(59, 130, 246, 0.15);
  }

  .gen-stats-header {
    display: flex;
    align-items: baseline;
    gap: 1rem;
    margin-bottom: 1.25rem;
  }

  .gen-stats-header h3 {
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--color-accent);
    margin: 0;
  }

  .gen-stats-subtitle {
    font-size: 0.875rem;
    color: var(--color-text-muted);
  }

  .gen-stats-content {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  .gen-stats-summary {
    width: 100%;
  }

  /* Comparison Table Styles */
  .gen-comparison-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
  }

  .gen-comparison-table thead {
    background: var(--color-bg);
  }

  .gen-comparison-table th {
    padding: 1rem 1.25rem;
    text-align: left;
    font-weight: 600;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    border-bottom: 1px solid var(--color-border);
  }

  .gen-comparison-table th:not(:first-child) {
    text-align: right;
  }

  .gen-row {
    border-bottom: 1px solid var(--color-border);
  }

  .gen-row:last-child {
    border-bottom: none;
  }

  .gen-row td {
    padding: 1.125rem 1.25rem;
  }

  .gen-row:hover {
    background: rgba(59, 130, 246, 0.05);
  }

  .baseline-row {
    background: rgba(148, 163, 184, 0.08);
  }

  .baseline-row:hover {
    background: rgba(148, 163, 184, 0.12);
  }

  .gen-name {
    display: flex;
    align-items: center;
    gap: 0.625rem;
  }

  .gen-indicator {
    width: 4px;
    height: 24px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .gen-name strong {
    font-size: 0.9375rem;
    color: var(--color-text);
  }

  .gen-arch {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    background: var(--color-bg);
    padding: 0.125rem 0.5rem;
    border-radius: 0.25rem;
    margin-left: 0.25rem;
  }

  .baseline-tag {
    background: rgba(148, 163, 184, 0.2);
    color: #94a3b8;
  }

  .gen-metric {
    text-align: right;
    white-space: nowrap;
  }

  .gen-metric-small {
    text-align: right;
    font-size: 0.8125rem;
  }

  .gen-value {
    font-family: var(--font-mono);
    font-weight: 600;
    font-size: 1rem;
    color: var(--color-text);
  }

  .gen-diff {
    font-size: 0.75rem;
    font-weight: 600;
    margin-left: 0.5rem;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
  }

  .gen-diff.positive {
    color: #22c55e;
    background: rgba(34, 197, 94, 0.15);
  }

  .gen-diff.negative {
    color: #ef4444;
    background: rgba(239, 68, 68, 0.15);
  }

  .gen-muted {
    color: var(--color-text-muted);
    font-size: 0.75rem;
  }

  .gen-stats-charts {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .gen-stats-chart-container {
    background-color: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 1rem;
    height: 220px;
  }

  @media (max-width: 900px) {
    .dashboard-layout {
      grid-template-columns: 1fr;
    }

    .sidebar {
      position: relative;
      max-height: none;
    }

    .summary-cards {
      grid-template-columns: repeat(2, 1fr);
    }

    .gen-comparison-table {
      font-size: 0.8125rem;
    }

    .gen-comparison-table th,
    .gen-row td {
      padding: 0.875rem 0.75rem;
    }

    .gen-value {
      font-size: 0.875rem;
    }

    .gen-diff {
      display: block;
      margin-left: 0;
      margin-top: 0.25rem;
    }

    .gen-stats-chart-container {
      height: 180px;
    }
  }

  /* CPU Stats Panel - uses same base styles as generation stats with different accent */
  .cpu-stats-panel {
    border-color: #22c55e;
    background: linear-gradient(135deg, var(--color-bg-secondary) 0%, rgba(34, 197, 94, 0.05) 100%);
    box-shadow: 0 4px 24px rgba(34, 197, 94, 0.15);
  }

  .cpu-stats-panel .gen-stats-header h3 {
    color: #22c55e;
  }

  /* CPU Links */
  .cpu-link {
    color: var(--color-text);
    text-decoration: none;
    transition: color 0.15s;
  }

  .cpu-link:hover {
    color: var(--color-accent);
    text-decoration: underline;
  }

  /* Data quality warning indicator */
  .quality-warning {
    cursor: help;
    color: #ff9800;
    font-size: 1.2em;
    margin-left: 0.25rem;
  }
</style>

<script define:vars={{ API_URL, DATA_URL }}>
  // Global benchmark data (loaded once from R2)
  let benchmarkData = null;

  // HTML escape function to prevent XSS
  function escapeHtml(str) {
    if (!str) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  // Helper function to format ordinal numbers (1st, 2nd, 3rd, 4th, etc.)
  function ordinal(n) {
    const s = ['th', 'st', 'nd', 'rd'];
    const v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
  }

  // Virtual generation display names and sort order
  const VIRTUAL_GEN_DISPLAY = {
    'ultra-1': 'Ultra 1',
    'ultra-2': 'Ultra 2',
    'arc': 'Arc',
  };
  const VIRTUAL_GEN_SORT_ORDER = {
    'ultra-1': 100,  // After 14th gen
    'ultra-2': 101,
    'arc': 102,
  };

  // Format generation for display
  function formatGeneration(g) {
    if (VIRTUAL_GEN_DISPLAY[g]) {
      return VIRTUAL_GEN_DISPLAY[g];
    }
    return `${ordinal(g)} Gen`;
  }

  // Check if a generation value is a virtual generation
  function isVirtualGen(g) {
    return typeof g === 'string' && VIRTUAL_GEN_DISPLAY.hasOwnProperty(g);
  }

  // Sort generations: numeric descending, then virtual generations in order
  function sortGenerations(generations) {
    return [...generations].sort((a, b) => {
      const aIsVirtual = isVirtualGen(a);
      const bIsVirtual = isVirtualGen(b);

      if (!aIsVirtual && !bIsVirtual) {
        // Both numeric: descending order
        return b - a;
      } else if (aIsVirtual && bIsVirtual) {
        // Both virtual: by sort order
        return VIRTUAL_GEN_SORT_ORDER[a] - VIRTUAL_GEN_SORT_ORDER[b];
      } else if (aIsVirtual) {
        // a is virtual, b is numeric: virtual comes after numeric
        return 1;
      } else {
        // a is numeric, b is virtual: numeric comes first
        return -1;
      }
    });
  }

  // Dashboard state
  const state = {
    filters: {
      generation: [],
      architecture: [],
      test: [],
      cpu: [],
      submitter: [],
      ecc: [],
    },
    // Track previous test filter to avoid unnecessary boxplot refetches
    _lastTestFilter: [],
    filterOptions: {
      generations: [],
      architectures: [],
      tests: [],
      submitters: [],
    },
    filterCounts: {
      generations: {},
      architectures: {},
      tests: {},
      cpus: {},
      submitters: {},
    },
    cpuScores: {},
    sort: { column: 'submitted_at', order: 'desc' },
    pagination: { limit: 100, offset: 0 },
    boxplotData: {},
  };

  // Test type colors - distinct palette for easy differentiation
  const testColors = {
    'h264_1080p': { bg: 'rgba(34, 197, 94, 0.7)', border: 'rgb(34, 197, 94)' },      // Green
    'h264_1080p_cpu': { bg: 'rgba(245, 158, 11, 0.7)', border: 'rgb(245, 158, 11)' }, // Amber
    'h264_4k': { bg: 'rgba(234, 88, 12, 0.7)', border: 'rgb(234, 88, 12)' },          // Orange
    'hevc_8bit': { bg: 'rgba(59, 130, 246, 0.7)', border: 'rgb(59, 130, 246)' },      // Blue
    'hevc_4k_10bit': { bg: 'rgba(168, 85, 247, 0.7)', border: 'rgb(168, 85, 247)' },  // Purple
  };

  // Fetch summary stats (from local data)
  async function fetchSummary() {
    try {
      document.getElementById('total-results').textContent = benchmarkData.meta.totalResults.toLocaleString();
      document.getElementById('unique-cpus').textContent = benchmarkData.meta.uniqueCpus.toLocaleString();
      document.getElementById('architectures-count').textContent = benchmarkData.meta.architecturesCount.toLocaleString();
    } catch (e) {
      console.error('Failed to fetch summary:', e);
    }
  }

  // Fetch filter options (from local data)
  async function fetchFilters() {
    try {
      // Extract unique values from benchmark data
      const generations = new Set();
      const architectures = new Set();
      const tests = new Set();

      for (const r of benchmarkData.results) {
        if (r.cpu_generation !== null) generations.add(String(r.cpu_generation));
        // Map architectures to virtual generations
        if (r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake') generations.add('ultra-1');
        if (r.architecture === 'Arrow Lake') generations.add('ultra-2');
        if (r.architecture === 'Alchemist' || r.architecture === 'Battlemage') generations.add('arc');
        if (r.architecture) architectures.add(r.architecture);
        if (r.test_name) tests.add(r.test_name);
      }

      state.filterOptions.generations = sortGenerations(Array.from(generations));
      state.filterOptions.architectures = Array.from(architectures).sort();
      state.filterOptions.tests = Array.from(tests);

      // Initial render
      renderFilters();
    } catch (e) {
      console.error('Failed to fetch filters:', e);
    }
  }

  // Fetch filter counts based on current selections (from local data)
  async function fetchFilterCounts() {
    try {
      const filtered = filterResultsLocal(benchmarkData, state.filters);

      const generations = {};
      const architectures = {};
      const tests = {};
      const cpus = {};
      const submitters = {};
      let eccYes = 0;
      let eccNo = 0;

      for (const r of filtered) {
        // Generations
        if (r.cpu_generation !== null) {
          const gen = String(r.cpu_generation);
          generations[gen] = (generations[gen] || 0) + 1;
        }

        // Virtual generations
        if (r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake') {
          generations['ultra-1'] = (generations['ultra-1'] || 0) + 1;
        }
        if (r.architecture === 'Arrow Lake') {
          generations['ultra-2'] = (generations['ultra-2'] || 0) + 1;
        }
        if (r.architecture === 'Alchemist' || r.architecture === 'Battlemage') {
          generations['arc'] = (generations['arc'] || 0) + 1;
        }

        // Architectures
        if (r.architecture) {
          architectures[r.architecture] = (architectures[r.architecture] || 0) + 1;
        }

        // Tests
        tests[r.test_name] = (tests[r.test_name] || 0) + 1;

        // CPUs
        cpus[r.cpu_raw] = (cpus[r.cpu_raw] || 0) + 1;

        // Submitters
        if (r.submitter_id) {
          submitters[r.submitter_id] = (submitters[r.submitter_id] || 0) + 1;
        }

        // ECC
        const hasEcc = benchmarkData.cpuFeatures[r.cpu_raw]?.ecc_support ?? false;
        if (hasEcc) eccYes++;
        else eccNo++;
      }

      state.filterCounts = {
        generations,
        architectures,
        tests,
        cpus,
        submitters,
        ecc: { yes: eccYes, no: eccNo },
      };
      updateFilterCounts();
    } catch (e) {
      console.error('Failed to fetch filter counts:', e);
    }
  }

  // Filter results locally based on current filter state
  function filterResultsLocal(data, filters) {
    return data.results.filter(r => {
      // Generation filter (including virtual generations)
      if (filters.generation.length > 0) {
        const gen = String(r.cpu_generation);
        const isUltra1 = r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake';
        const isUltra2 = r.architecture === 'Arrow Lake';
        const isArc = r.architecture === 'Alchemist' || r.architecture === 'Battlemage';

        const matchesGen = filters.generation.includes(gen);
        const matchesUltra1 = filters.generation.includes('ultra-1') && isUltra1;
        const matchesUltra2 = filters.generation.includes('ultra-2') && isUltra2;
        const matchesArc = filters.generation.includes('arc') && isArc;

        if (!matchesGen && !matchesUltra1 && !matchesUltra2 && !matchesArc) {
          return false;
        }
      }

      // Architecture filter
      if (filters.architecture.length > 0 && r.architecture) {
        if (!filters.architecture.includes(r.architecture)) return false;
      }

      // Test filter
      if (filters.test.length > 0) {
        if (!filters.test.includes(r.test_name)) return false;
      }

      // CPU filter
      if (filters.cpu.length > 0) {
        if (!filters.cpu.includes(r.cpu_raw)) return false;
      }

      // Submitter filter
      if (filters.submitter.length > 0) {
        if (!r.submitter_id || !filters.submitter.includes(r.submitter_id)) return false;
      }

      // ECC filter
      if (filters.ecc.length > 0) {
        const hasEcc = data.cpuFeatures[r.cpu_raw]?.ecc_support ?? false;
        if (filters.ecc.includes('yes') && !hasEcc) return false;
        if (filters.ecc.includes('no') && hasEcc) return false;
      }

      return true;
    });
  }

  // Render filter checkboxes
  function renderFilters() {
    // Generations
    const genList = document.getElementById('generation-list');
    genList.innerHTML = state.filterOptions.generations.map(g => `
      <label class="checkbox-item" data-value="${g}">
        <input type="checkbox" value="${g}" data-filter="generation" />
        <span>${formatGeneration(g)}</span>
        <span class="count"></span>
      </label>
    `).join('');

    // Architectures
    const archList = document.getElementById('architecture-list');
    archList.innerHTML = state.filterOptions.architectures.map(a => `
      <label class="checkbox-item" data-value="${a}">
        <input type="checkbox" value="${a}" data-filter="architecture" />
        <span>${a}</span>
        <span class="count"></span>
      </label>
    `).join('');

    // Tests
    const testList = document.getElementById('test-list');
    testList.innerHTML = state.filterOptions.tests.map(t => `
      <label class="checkbox-item" data-value="${t}">
        <input type="checkbox" value="${t}" data-filter="test" />
        <span>${t}</span>
        <span class="count"></span>
      </label>
    `).join('');

    // Setup checkbox change handlers
    document.querySelectorAll('[data-filter]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });
  }

  // Update filter counts and disable/enable options
  function updateFilterCounts() {
    // Update generations
    document.querySelectorAll('#generation-list .checkbox-item').forEach(item => {
      const value = item.dataset.value;
      const count = state.filterCounts.generations[value] || 0;
      const countEl = item.querySelector('.count');
      const checkbox = item.querySelector('input');

      countEl.textContent = `(${count})`;

      // Disable if count is 0 and not currently selected
      const isSelected = state.filters.generation.includes(value);
      if (count === 0 && !isSelected) {
        item.classList.add('disabled');
        checkbox.disabled = true;
      } else {
        item.classList.remove('disabled');
        checkbox.disabled = false;
      }
    });

    // Update architectures
    document.querySelectorAll('#architecture-list .checkbox-item').forEach(item => {
      const value = item.dataset.value;
      const count = state.filterCounts.architectures[value] || 0;
      const countEl = item.querySelector('.count');
      const checkbox = item.querySelector('input');

      countEl.textContent = `(${count})`;

      const isSelected = state.filters.architecture.includes(value);
      if (count === 0 && !isSelected) {
        item.classList.add('disabled');
        checkbox.disabled = true;
      } else {
        item.classList.remove('disabled');
        checkbox.disabled = false;
      }
    });

    // Update tests
    document.querySelectorAll('#test-list .checkbox-item').forEach(item => {
      const value = item.dataset.value;
      const count = state.filterCounts.tests[value] || 0;
      const countEl = item.querySelector('.count');
      const checkbox = item.querySelector('input');

      countEl.textContent = `(${count})`;

      const isSelected = state.filters.test.includes(value);
      if (count === 0 && !isSelected) {
        item.classList.add('disabled');
        checkbox.disabled = true;
      } else {
        item.classList.remove('disabled');
        checkbox.disabled = false;
      }
    });

    // Update CPU and submitter lists with counts
    renderCpuList(document.getElementById('cpu-search').value);
    renderSubmitterList(document.getElementById('submitter-search').value);

    // Update ECC counts
    const eccCounts = state.filterCounts.ecc || {};
    document.getElementById('ecc-yes-count').textContent = `(${eccCounts.yes || 0})`;
    document.getElementById('ecc-no-count').textContent = `(${eccCounts.no || 0})`;
  }

  // Render submitter list
  function renderSubmitterList(searchTerm = '') {
    const submitterList = document.getElementById('submitter-list');
    const submitterCounts = state.filterCounts.submitters || {};

    let submitterEntries = Object.entries(submitterCounts)
      .filter(([submitter]) => submitter.toLowerCase().includes(searchTerm.toLowerCase()))
      .sort((a, b) => b[1] - a[1])
      .slice(0, 30);

    if (submitterEntries.length === 0) {
      submitterList.innerHTML = '<div style="font-size: 0.75rem; color: var(--color-text-muted); padding: 0.5rem 0;">No submitters found</div>';
      return;
    }

    submitterList.innerHTML = submitterEntries.map(([submitter, count]) => {
      const escaped = escapeHtml(submitter);
      const displayText = submitter.length > 20 ? submitter.slice(0, 20) + '...' : submitter;
      return `
        <label class="checkbox-item" data-value="${escaped}">
          <input type="checkbox" value="${escaped}" data-filter="submitter" ${state.filters.submitter.includes(submitter) ? 'checked' : ''} />
          <span title="${escaped}">${escapeHtml(displayText)}</span>
          <span class="count">(${count})</span>
        </label>
      `;
    }).join('');

    // Re-attach handlers
    submitterList.querySelectorAll('[data-filter]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });
  }

  // Strip Intel branding from CPU names for cleaner display
  function stripIntelBranding(cpuName) {
    return cpuName
      .replace(/Intel\(R\)\s*/gi, '')
      .replace(/Core\(TM\)\s*/gi, '')
      .replace(/\s+CPU\s*@\s*[\d.]+GHz/gi, '')
      .replace(/\s*\d{1,2}th Gen\s*/gi, '') // Remove "13th Gen" etc
      .replace(/\s+/g, ' ')
      .trim();
  }

  // Generate a link to the CPU's generation page
  function getCpuLink(cpuRaw, architecture, generation) {
    // Arc GPUs link to Arc pages
    if (architecture && (architecture.includes('Arc') || architecture === 'Alchemist' || architecture === 'Battlemage')) {
      return '/gpu/arc/all';
    }
    // Meteor Lake links to Ultra Series 1
    if (architecture === 'Meteor Lake') {
      return '/cpu/gen/ultra-1';
    }
    // Arrow Lake or Lunar Lake links to Ultra Series 2
    if (architecture === 'Arrow Lake' || architecture === 'Lunar Lake') {
      return '/cpu/gen/ultra-2';
    }
    // Standard generations 2-14
    if (generation && generation >= 2 && generation <= 14) {
      return `/cpu/gen/${generation}`;
    }
    return null;
  }

  // Render CPU name with optional link to generation page
  function renderCpuName(cpuRaw, architecture, generation) {
    const displayName = stripIntelBranding(cpuRaw);
    const link = getCpuLink(cpuRaw, architecture, generation);
    const escapedCpu = escapeHtml(cpuRaw);
    const escapedDisplay = escapeHtml(displayName);
    if (link) {
      return `<a href="${link}" class="cpu-link" title="${escapedCpu}">${escapedDisplay}</a>`;
    }
    return `<span title="${escapedCpu}">${escapedDisplay}</span>`;
  }

  // Render CPU list (filtered by search and with counts)
  function renderCpuList(searchTerm = '') {
    const cpuList = document.getElementById('cpu-list');
    const cpuCounts = state.filterCounts.cpus || {};

    // Build list from counts (already filtered by current selections)
    // Search against both original and stripped names
    let cpuEntries = Object.entries(cpuCounts)
      .filter(([cpu]) => {
        const searchLower = searchTerm.toLowerCase();
        return cpu.toLowerCase().includes(searchLower) ||
               stripIntelBranding(cpu).toLowerCase().includes(searchLower);
      })
      .sort((a, b) => b[1] - a[1])
      .slice(0, 50);

    // If no filters applied, show all CPUs
    if (cpuEntries.length === 0 && Object.keys(cpuCounts).length === 0) {
      cpuList.innerHTML = '<div style="font-size: 0.75rem; color: var(--color-text-muted); padding: 0.5rem 0;">No CPUs match current filters</div>';
      return;
    }

    cpuList.innerHTML = cpuEntries.map(([cpu, count]) => {
      const displayName = stripIntelBranding(cpu);
      const displayText = displayName.length > 22 ? displayName.slice(0, 22) + '...' : displayName;
      const escapedCpu = escapeHtml(cpu);
      const escapedDisplay = escapeHtml(displayText);
      return `
        <label class="checkbox-item" data-value="${escapedCpu}">
          <input type="checkbox" value="${escapedCpu}" data-filter="cpu" ${state.filters.cpu.includes(cpu) ? 'checked' : ''} />
          <span title="${escapedCpu}">${escapedDisplay}</span>
          <span class="count">(${count})</span>
        </label>
      `;
    }).join('');

    // Re-attach handlers
    cpuList.querySelectorAll('[data-filter]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });
  }

  // Debounce timer for filter changes
  let filterDebounceTimer = null;

  // Handle filter checkbox changes
  function handleFilterChange(e) {
    const filterType = e.target.dataset.filter;
    const value = e.target.value;
    const checked = e.target.checked;

    if (checked) {
      if (!state.filters[filterType].includes(value)) {
        state.filters[filterType].push(value);
      }
    } else {
      state.filters[filterType] = state.filters[filterType].filter(v => v !== value);
    }

    state.pagination.offset = 0;

    // Debounce API calls to collapse rapid filter clicks
    clearTimeout(filterDebounceTimer);
    filterDebounceTimer = setTimeout(() => {
      onFiltersChanged();
    }, 150);
  }

  // Called when filters change - updates everything
  async function onFiltersChanged() {
    // Check if test filter changed (only thing that affects boxplot charts)
    const testFilterChanged = JSON.stringify(state.filters.test) !== JSON.stringify(state._lastTestFilter);
    state._lastTestFilter = [...state.filters.test];

    const promises = [
      fetchFilterCounts(),
      fetchResults(),
      fetchGenerationStats(),
      fetchCpuStats(),
    ];

    // Only refetch boxplot data if test filter changed
    // Charts show all generations + Arc regardless of other filters
    if (testFilterChanged) {
      promises.push(fetchBoxplotData());
    }

    await Promise.all(promises);
  }

  // Generation colors for multi-generation chart - high contrast palette
  const genColors = {
    6: { bg: 'rgba(220, 38, 38, 0.8)', border: 'rgb(220, 38, 38)' },       // Red
    7: { bg: 'rgba(234, 88, 12, 0.8)', border: 'rgb(234, 88, 12)' },       // Orange
    8: { bg: 'rgba(120, 120, 130, 0.6)', border: 'rgb(120, 120, 130)' },   // Gray (baseline)
    9: { bg: 'rgba(202, 138, 4, 0.8)', border: 'rgb(202, 138, 4)' },       // Amber
    10: { bg: 'rgba(22, 163, 74, 0.8)', border: 'rgb(22, 163, 74)' },      // Green
    11: { bg: 'rgba(20, 184, 166, 0.8)', border: 'rgb(20, 184, 166)' },    // Teal
    12: { bg: 'rgba(6, 182, 212, 0.8)', border: 'rgb(6, 182, 212)' },      // Cyan
    13: { bg: 'rgba(59, 130, 246, 0.85)', border: 'rgb(59, 130, 246)' },   // Blue
    14: { bg: 'rgba(168, 85, 247, 0.8)', border: 'rgb(168, 85, 247)' },    // Purple
    'U1': { bg: 'rgba(236, 72, 153, 0.8)', border: 'rgb(236, 72, 153)' },  // Pink - Ultra Series 1
    'U2': { bg: 'rgba(139, 92, 246, 0.8)', border: 'rgb(139, 92, 246)' },  // Violet - Ultra Series 2
    'Arc': { bg: 'rgba(14, 165, 233, 0.8)', border: 'rgb(14, 165, 233)' }, // Sky - Arc GPUs
  };

  // Fetch and display generation statistics (from local data)
  async function fetchGenerationStats() {
    const statsContainer = document.getElementById('generation-stats');
    const statsSummary = document.getElementById('gen-stats-summary');
    const statsTitle = document.getElementById('gen-stats-title');
    const statsSubtitle = document.getElementById('gen-stats-subtitle');

    // Check for Arc architectures (Alchemist/Battlemage)
    const arcArchitectures = state.filters.architecture.filter(a => a === 'Alchemist' || a === 'Battlemage');
    const hasArcFilter = arcArchitectures.length > 0;
    const hasGenFilter = state.filters.generation.length > 0;

    // Show when generations OR Arc architectures are selected
    if (!hasGenFilter && !hasArcFilter) {
      statsContainer.style.display = 'none';
      // Destroy charts if exist
      if (window.genFpsChart) { window.genFpsChart.destroy(); window.genFpsChart = null; }
      if (window.genWattsChart) { window.genWattsChart.destroy(); window.genWattsChart = null; }
      if (window.genEfficiencyChart) { window.genEfficiencyChart.destroy(); window.genEfficiencyChart = null; }
      return;
    }

    try {
      // Helper to compute stats from results
      function computeGroupStats(results, groupKey, isArc = false) {
        const byTest = {};
        const uniqueCpus = new Set();

        for (const r of results) {
          uniqueCpus.add(r.cpu_raw);
          if (!byTest[r.test_name]) byTest[r.test_name] = [];
          byTest[r.test_name].push(r);
        }

        const by_test = Object.entries(byTest).map(([testName, testResults]) => {
          const fpsVals = testResults.map(r => r.avg_fps);
          const wattsVals = testResults.filter(r => r.avg_watts !== null).map(r => r.avg_watts);
          const effVals = testResults.filter(r => r.fps_per_watt !== null).map(r => r.fps_per_watt);

          return {
            test_name: testName,
            result_count: testResults.length,
            avg_fps: fpsVals.reduce((a, b) => a + b, 0) / fpsVals.length,
            avg_watts: wattsVals.length > 0 ? wattsVals.reduce((a, b) => a + b, 0) / wattsVals.length : null,
            fps_per_watt: effVals.length > 0 ? effVals.reduce((a, b) => a + b, 0) / effVals.length : null,
          };
        });

        const allFps = results.map(r => r.avg_fps);
        const allWatts = results.filter(r => r.avg_watts !== null).map(r => r.avg_watts);
        const allEff = results.filter(r => r.fps_per_watt !== null).map(r => r.fps_per_watt);

        return {
          generation: groupKey,
          architecture: isArc ? 'Arc' : (results[0]?.architecture || null),
          isArc,
          overall: {
            total_results: results.length,
            unique_cpus: uniqueCpus.size,
            avg_fps: allFps.length > 0 ? allFps.reduce((a, b) => a + b, 0) / allFps.length : 0,
            avg_watts: allWatts.length > 0 ? allWatts.reduce((a, b) => a + b, 0) / allWatts.length : null,
            fps_per_watt: allEff.length > 0 ? allEff.reduce((a, b) => a + b, 0) / allEff.length : null,
          },
          by_test,
        };
      }

      // Build data structure
      const data = {
        success: true,
        generations: [],
        data: [],
        all_tests: new Set(),
        baseline_overall: null,
        baseline_by_test: [],
      };

      // Get baseline (8th gen) data
      const baselineResults = benchmarkData.results.filter(r => r.cpu_generation === 8);
      if (baselineResults.length > 0) {
        const baselineStats = computeGroupStats(baselineResults, '8');
        data.baseline_overall = baselineStats.overall;
        data.baseline_by_test = baselineStats.by_test;
        baselineStats.by_test.forEach(t => data.all_tests.add(t.test_name));
      }

      // Process generation filters
      for (const gen of state.filters.generation) {
        let results;
        let groupKey = gen;
        let isArc = false;

        if (gen === 'ultra-1') {
          results = benchmarkData.results.filter(r =>
            r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake'
          );
        } else if (gen === 'ultra-2') {
          results = benchmarkData.results.filter(r => r.architecture === 'Arrow Lake');
        } else if (gen === 'arc') {
          results = benchmarkData.results.filter(r =>
            r.architecture === 'Alchemist' || r.architecture === 'Battlemage'
          );
          isArc = true;
        } else {
          const genNum = parseInt(gen);
          results = benchmarkData.results.filter(r => r.cpu_generation === genNum);
          data.generations.push(genNum);
        }

        if (results.length > 0) {
          const stats = computeGroupStats(results, groupKey, isArc);
          data.data.push(stats);
          stats.by_test.forEach(t => data.all_tests.add(t.test_name));
        }
      }

      // Process Arc architecture filter (if selected via architecture filter)
      if (hasArcFilter && !state.filters.generation.includes('arc')) {
        const arcResults = benchmarkData.results.filter(r =>
          r.architecture === 'Alchemist' || r.architecture === 'Battlemage'
        );
        if (arcResults.length > 0) {
          const arcStats = computeGroupStats(arcResults, 'Arc', true);
          data.data.push(arcStats);
          arcStats.by_test.forEach(t => data.all_tests.add(t.test_name));
        }
      }

      data.all_tests = Array.from(data.all_tests).sort();

      if (!data.success || !data.data || data.data.length === 0) {
        statsContainer.style.display = 'none';
        return;
      }

      statsContainer.style.display = 'block';

      // Build title based on what's selected
      const hasGenerations = data.generations && data.generations.length > 0;
      const hasArchitectures = data.data.some(d => d.isArc);

      let titleText = '';
      if (hasGenerations && !hasArchitectures) {
        const genList = data.generations.map(g => ordinal(g)).join(', ');
        titleText = data.generations.length === 1
          ? `${genList} Gen vs 8th Gen Baseline`
          : `${genList} Gen Comparison`;
      } else if (!hasGenerations && hasArchitectures) {
        titleText = 'Intel Arc vs 8th Gen Baseline';
      } else {
        const genList = data.generations.map(g => ordinal(g)).join(', ');
        titleText = `${genList} Gen + Arc Comparison`;
      }
      statsTitle.textContent = titleText;

      // Build subtitle with total results
      const totalResults = data.data.reduce((sum, g) => sum + g.overall.total_results, 0);
      const totalCpus = data.data.reduce((sum, g) => sum + g.overall.unique_cpus, 0);
      statsSubtitle.textContent = `${totalResults} results from ${totalCpus} unique ${hasArchitectures && !hasGenerations ? 'GPUs' : 'CPUs'}`;

      // Build comparison table - cleaner presentation of all metrics
      const baselineFps = data.baseline_overall?.avg_fps || 0;
      const baselineWatts = data.baseline_overall?.avg_watts;
      const baselineEff = data.baseline_overall?.fps_per_watt;

      // Helper to format % diff
      const formatDiff = (val, baseline) => {
        if (!baseline || baseline === 0 || val === null || val === undefined) return '';
        const diff = ((val - baseline) / baseline * 100);
        const cls = diff >= 0 ? 'positive' : 'negative';
        return `<span class="gen-diff ${cls}">${diff >= 0 ? '+' : ''}${diff.toFixed(0)}%</span>`;
      };

      let summaryHtml = `
        <table class="gen-comparison-table">
          <thead>
            <tr>
              <th>Generation</th>
              <th>Avg FPS</th>
              <th>Avg Watts</th>
              <th>Efficiency</th>
              <th>Results</th>
            </tr>
          </thead>
          <tbody>
      `;

      // Add row for each selected generation/architecture
      for (const genData of data.data) {
        const isArc = genData.isArc;
        const color = isArc ? '#10b981' : (genColors[genData.generation]?.border || '#3b82f6'); // Green for Arc
        const displayName = isArc ? genData.architecture : `${ordinal(genData.generation)} Gen`;
        const archLabel = isArc ? '' : (genData.architecture ? `<span class="gen-arch">${genData.architecture}</span>` : '');

        summaryHtml += `
          <tr class="gen-row" style="--gen-color: ${color}">
            <td class="gen-name">
              <span class="gen-indicator" style="background: ${color}"></span>
              <strong>${displayName}</strong>
              ${archLabel}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${genData.overall.avg_fps?.toFixed(1) || '-'}</span>
              ${formatDiff(genData.overall.avg_fps, baselineFps)}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${genData.overall.avg_watts?.toFixed(1) || '-'}</span>
              ${genData.overall.avg_watts ? formatDiff(baselineWatts, genData.overall.avg_watts) : ''}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${genData.overall.fps_per_watt?.toFixed(1) || '-'}</span>
              ${formatDiff(genData.overall.fps_per_watt, baselineEff)}
            </td>
            <td class="gen-metric-small">
              ${genData.overall.total_results} <span class="gen-muted">(${genData.overall.unique_cpus} ${isArc ? 'GPUs' : 'CPUs'})</span>
            </td>
          </tr>
        `;
      }

      // Add baseline row if 8th gen isn't already selected
      if (!data.generations || !data.generations.includes(8)) {
        summaryHtml += `
          <tr class="gen-row baseline-row">
            <td class="gen-name">
              <span class="gen-indicator" style="background: ${genColors[8].border}"></span>
              <strong>8th Gen</strong>
              <span class="gen-arch baseline-tag">Baseline</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${baselineFps?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${baselineWatts?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${baselineEff?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric-small gen-muted">Reference</td>
          </tr>
        `;
      }

      summaryHtml += `
          </tbody>
        </table>
      `;

      statsSummary.innerHTML = summaryHtml;

      // Build 3 comparison charts - FPS, Watts, Efficiency
      const testNames = data.all_tests;

      // Helper to build datasets for a given metric
      const buildDatasets = (metric) => {
        const datasets = data.data.map(genData => {
          const isArc = genData.isArc;
          const colors = isArc
            ? { bg: 'rgba(16, 185, 129, 0.7)', border: 'rgb(16, 185, 129)' } // Green for Arc
            : (genColors[genData.generation] || { bg: 'rgba(59, 130, 246, 0.7)', border: 'rgb(59, 130, 246)' });
          const label = isArc ? genData.architecture : `${ordinal(genData.generation)} Gen`;

          return {
            label,
            data: testNames.map(testName => {
              const testInfo = genData.by_test.find(t => t.test_name === testName);
              return testInfo?.[metric] || 0;
            }),
            backgroundColor: colors.bg,
            borderColor: colors.border,
            borderWidth: 1,
          };
        });

        // Add baseline dataset if 8th gen isn't already selected
        if (!data.generations || !data.generations.includes(8)) {
          datasets.push({
            label: '8th Gen (Baseline)',
            data: testNames.map(testName => {
              const testInfo = data.baseline_by_test?.find(t => t.test_name === testName);
              return testInfo?.[metric] || 0;
            }),
            backgroundColor: genColors[8].bg,
            borderColor: genColors[8].border,
            borderWidth: 1,
          });
        }
        return datasets;
      };

      // Helper to create a chart
      const createComparisonChart = (canvasId, title, yLabel, datasets, baselineData, metric) => {
        const canvas = document.getElementById(canvasId);
        return new Chart(canvas, {
          type: 'bar',
          data: { labels: testNames, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
                labels: { color: '#f1f5f9', font: { size: 11 } },
              },
              title: {
                display: true,
                text: title,
                color: '#f1f5f9',
                font: { size: 13, weight: '600' },
              },
              tooltip: {
                callbacks: {
                  afterLabel: (context) => {
                    const gen = parseInt(context.dataset.label);
                    if (gen !== 8 && baselineData) {
                      const testName = testNames[context.dataIndex];
                      const baselineTest = baselineData.find(t => t.test_name === testName);
                      const baseVal = baselineTest?.[metric];
                      if (baseVal && baseVal > 0) {
                        // For watts, lower is better so invert the comparison
                        const diff = metric === 'avg_watts'
                          ? ((baseVal - context.raw) / baseVal * 100)
                          : ((context.raw - baseVal) / baseVal * 100);
                        return `${diff >= 0 ? '+' : ''}${diff.toFixed(0)}% vs 8th Gen`;
                      }
                    }
                    return '';
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#94a3b8', font: { size: 10 } },
                grid: { color: '#334155' },
              },
              y: {
                ticks: { color: '#94a3b8' },
                grid: { color: '#334155' },
                title: { display: true, text: yLabel, color: '#94a3b8' },
              },
            },
          },
        });
      };

      // Destroy existing charts
      if (window.genFpsChart) window.genFpsChart.destroy();
      if (window.genWattsChart) window.genWattsChart.destroy();
      if (window.genEfficiencyChart) window.genEfficiencyChart.destroy();

      // Create 3 charts
      window.genFpsChart = createComparisonChart(
        'gen-fps-chart',
        'Average FPS by Test Type',
        'Frames per Second',
        buildDatasets('avg_fps'),
        data.baseline_by_test,
        'avg_fps'
      );

      window.genWattsChart = createComparisonChart(
        'gen-watts-chart',
        'Average Power Usage by Test Type',
        'Watts',
        buildDatasets('avg_watts'),
        data.baseline_by_test,
        'avg_watts'
      );

      window.genEfficiencyChart = createComparisonChart(
        'gen-efficiency-chart',
        'Efficiency (FPS per Watt) by Test Type',
        'FPS/Watt',
        buildDatasets('fps_per_watt'),
        data.baseline_by_test,
        'fps_per_watt'
      );
    } catch (e) {
      console.error('Failed to fetch generation stats:', e);
      statsContainer.style.display = 'none';
    }
  }

  // CPU colors for multi-CPU chart - distinct palette
  const cpuColors = [
    { bg: 'rgba(34, 197, 94, 0.8)', border: 'rgb(34, 197, 94)' },      // Green
    { bg: 'rgba(59, 130, 246, 0.8)', border: 'rgb(59, 130, 246)' },    // Blue
    { bg: 'rgba(168, 85, 247, 0.8)', border: 'rgb(168, 85, 247)' },    // Purple
    { bg: 'rgba(234, 88, 12, 0.8)', border: 'rgb(234, 88, 12)' },      // Orange
    { bg: 'rgba(6, 182, 212, 0.8)', border: 'rgb(6, 182, 212)' },      // Cyan
    { bg: 'rgba(236, 72, 153, 0.8)', border: 'rgb(236, 72, 153)' },    // Pink
    { bg: 'rgba(202, 138, 4, 0.8)', border: 'rgb(202, 138, 4)' },      // Amber
    { bg: 'rgba(20, 184, 166, 0.8)', border: 'rgb(20, 184, 166)' },    // Teal
  ];

  // Fetch and display CPU statistics (from local data)
  async function fetchCpuStats() {
    const statsContainer = document.getElementById('cpu-stats');
    const statsSummary = document.getElementById('cpu-stats-summary');
    const statsTitle = document.getElementById('cpu-stats-title');
    const statsSubtitle = document.getElementById('cpu-stats-subtitle');

    // Show when one or more CPUs are selected
    if (state.filters.cpu.length === 0) {
      statsContainer.style.display = 'none';
      // Destroy charts if exist
      if (window.cpuFpsChart) { window.cpuFpsChart.destroy(); window.cpuFpsChart = null; }
      if (window.cpuWattsChart) { window.cpuWattsChart.destroy(); window.cpuWattsChart = null; }
      if (window.cpuEfficiencyChart) { window.cpuEfficiencyChart.destroy(); window.cpuEfficiencyChart = null; }
      return;
    }

    try {
      // Build CPU stats from local data
      const cpuList = state.filters.cpu;
      const filtered = benchmarkData.results.filter(r => cpuList.includes(r.cpu_raw));

      // Group by CPU
      const byCpu = {};
      for (const r of filtered) {
        if (!byCpu[r.cpu_raw]) byCpu[r.cpu_raw] = [];
        byCpu[r.cpu_raw].push(r);
      }

      // Build stats for each CPU
      const cpuData = Object.entries(byCpu).map(([cpu, results]) => {
        const byTest = {};
        for (const r of results) {
          if (!byTest[r.test_name]) byTest[r.test_name] = [];
          byTest[r.test_name].push(r);
        }

        const by_test = Object.entries(byTest).map(([testName, testResults]) => {
          const fpsVals = testResults.map(r => r.avg_fps);
          const wattsVals = testResults.filter(r => r.avg_watts !== null).map(r => r.avg_watts);
          const effVals = testResults.filter(r => r.fps_per_watt !== null).map(r => r.fps_per_watt);

          return {
            test_name: testName,
            result_count: testResults.length,
            avg_fps: fpsVals.reduce((a, b) => a + b, 0) / fpsVals.length,
            avg_watts: wattsVals.length > 0 ? wattsVals.reduce((a, b) => a + b, 0) / wattsVals.length : null,
            fps_per_watt: effVals.length > 0 ? effVals.reduce((a, b) => a + b, 0) / effVals.length : null,
          };
        });

        const allFps = results.map(r => r.avg_fps);
        const allWatts = results.filter(r => r.avg_watts !== null).map(r => r.avg_watts);
        const allEff = results.filter(r => r.fps_per_watt !== null).map(r => r.fps_per_watt);

        return {
          cpu_raw: cpu,
          architecture: results[0]?.architecture || null,
          cpu_generation: results[0]?.cpu_generation || null,
          overall: {
            total_results: results.length,
            avg_fps: allFps.length > 0 ? allFps.reduce((a, b) => a + b, 0) / allFps.length : 0,
            avg_watts: allWatts.length > 0 ? allWatts.reduce((a, b) => a + b, 0) / allWatts.length : null,
            fps_per_watt: allEff.length > 0 ? allEff.reduce((a, b) => a + b, 0) / allEff.length : null,
          },
          by_test,
        };
      });

      // Get all test names
      const allTests = [...new Set(filtered.map(r => r.test_name))].sort();

      const data = {
        success: true,
        data: cpuData,
        all_tests: allTests,
      };

      if (!data.success || !data.data || data.data.length === 0) {
        statsContainer.style.display = 'none';
        return;
      }

      statsContainer.style.display = 'block';

      // Build title
      const cpuCount = data.data.length;
      statsTitle.textContent = cpuCount === 1
        ? `CPU: ${stripIntelBranding(data.data[0].cpu_raw)}`
        : `Comparing ${cpuCount} CPUs`;

      // Build subtitle with total results
      const totalResults = data.data.reduce((sum, c) => sum + c.overall.total_results, 0);
      statsSubtitle.textContent = `${totalResults} benchmark results`;

      // Build comparison table
      let summaryHtml = `
        <table class="gen-comparison-table">
          <thead>
            <tr>
              <th>CPU</th>
              <th>Architecture</th>
              <th>Avg FPS</th>
              <th>Avg Watts</th>
              <th>Efficiency</th>
              <th>Results</th>
            </tr>
          </thead>
          <tbody>
      `;

      // Add row for each CPU
      data.data.forEach((cpuData, idx) => {
        const color = cpuColors[idx % cpuColors.length].border;
        const displayName = stripIntelBranding(cpuData.cpu_raw);
        summaryHtml += `
          <tr class="gen-row" style="--gen-color: ${color}">
            <td class="gen-name">
              <span class="gen-indicator" style="background: ${color}"></span>
              <strong title="${cpuData.cpu_raw}">${displayName.length > 30 ? displayName.slice(0, 30) + '...' : displayName}</strong>
            </td>
            <td>
              ${cpuData.architecture ? `<span class="gen-arch">${cpuData.architecture}</span>` : '-'}
              ${cpuData.cpu_generation ? `<span class="gen-arch">${ordinal(cpuData.cpu_generation)} Gen</span>` : ''}
            </td>
            <td class="gen-metric">
              <span class="gen-value">${cpuData.overall.avg_fps?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${cpuData.overall.avg_watts?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric">
              <span class="gen-value">${cpuData.overall.fps_per_watt?.toFixed(1) || '-'}</span>
            </td>
            <td class="gen-metric-small">
              ${cpuData.overall.total_results}
            </td>
          </tr>
        `;
      });

      summaryHtml += `
          </tbody>
        </table>
      `;

      statsSummary.innerHTML = summaryHtml;

      // Build 3 comparison charts - FPS, Watts, Efficiency
      const testNames = data.all_tests;

      // Helper to build datasets for a given metric
      const buildDatasets = (metric) => {
        return data.data.map((cpuData, idx) => {
          const colors = cpuColors[idx % cpuColors.length];
          const displayName = stripIntelBranding(cpuData.cpu_raw);
          return {
            label: displayName.length > 20 ? displayName.slice(0, 20) + '...' : displayName,
            data: testNames.map(testName => {
              const testInfo = cpuData.by_test.find(t => t.test_name === testName);
              return testInfo?.[metric] || 0;
            }),
            backgroundColor: colors.bg,
            borderColor: colors.border,
            borderWidth: 1,
          };
        });
      };

      // Helper to create a chart
      const createCpuComparisonChart = (canvasId, title, yLabel, datasets) => {
        const canvas = document.getElementById(canvasId);
        return new Chart(canvas, {
          type: 'bar',
          data: { labels: testNames, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
                labels: { color: '#f1f5f9', font: { size: 11 } },
              },
              title: {
                display: true,
                text: title,
                color: '#f1f5f9',
                font: { size: 13, weight: '600' },
              },
            },
            scales: {
              x: {
                ticks: { color: '#94a3b8', font: { size: 10 } },
                grid: { color: '#334155' },
              },
              y: {
                ticks: { color: '#94a3b8' },
                grid: { color: '#334155' },
                title: { display: true, text: yLabel, color: '#94a3b8' },
              },
            },
          },
        });
      };

      // Destroy existing charts
      if (window.cpuFpsChart) window.cpuFpsChart.destroy();
      if (window.cpuWattsChart) window.cpuWattsChart.destroy();
      if (window.cpuEfficiencyChart) window.cpuEfficiencyChart.destroy();

      // Create 3 charts
      window.cpuFpsChart = createCpuComparisonChart(
        'cpu-fps-chart',
        'Average FPS by Test Type',
        'Frames per Second',
        buildDatasets('avg_fps')
      );

      window.cpuWattsChart = createCpuComparisonChart(
        'cpu-watts-chart',
        'Average Power Usage by Test Type',
        'Watts',
        buildDatasets('avg_watts')
      );

      window.cpuEfficiencyChart = createCpuComparisonChart(
        'cpu-efficiency-chart',
        'Efficiency (FPS per Watt) by Test Type',
        'FPS/Watt',
        buildDatasets('fps_per_watt')
      );
    } catch (e) {
      console.error('Failed to fetch CPU stats:', e);
      statsContainer.style.display = 'none';
    }
  }

  // Toggle generation filter (called from chart click)
  function toggleGenerationFilter(generation) {
    const genStr = String(generation);
    const checkbox = document.querySelector(`[data-filter="generation"][value="${genStr}"]`);

    if (state.filters.generation.includes(genStr)) {
      state.filters.generation = state.filters.generation.filter(g => g !== genStr);
      if (checkbox) checkbox.checked = false;
    } else {
      state.filters.generation.push(genStr);
      if (checkbox) checkbox.checked = true;
    }

    state.pagination.offset = 0;
    onFiltersChanged();
  }

  // Make it globally accessible for chart click handler
  window.toggleGenerationFilter = toggleGenerationFilter;

  // Toggle architecture filter (called from chart click for Arc)
  function toggleArchitectureFilter(architecture) {
    const archStr = String(architecture);
    const checkbox = document.querySelector(`[data-filter="architecture"][value="${archStr}"]`);

    if (state.filters.architecture.includes(archStr)) {
      state.filters.architecture = state.filters.architecture.filter(a => a !== archStr);
      if (checkbox) checkbox.checked = false;
    } else {
      state.filters.architecture.push(archStr);
      if (checkbox) checkbox.checked = true;
    }

    state.pagination.offset = 0;
    onFiltersChanged();
  }

  // Make it globally accessible for chart click handler
  window.toggleArchitectureFilter = toggleArchitectureFilter;

  // Fetch boxplot data (from local data)
  // NOTE: Charts always show all generations + Ultra + Arc, regardless of filters
  // Architecture filter only affects the results table, not the charts
  async function fetchBoxplotData() {
    try {
      const metrics = ['avg_fps', 'avg_watts', 'fps_per_watt'];

      // Filter only by test type for charts
      let filtered = benchmarkData.results;
      if (state.filters.test.length > 0) {
        filtered = filtered.filter(r => state.filters.test.includes(r.test_name));
      }

      // Helper to compute percentile
      function percentile(sorted, p) {
        const idx = (p / 100) * (sorted.length - 1);
        const lower = Math.floor(idx);
        const upper = Math.ceil(idx);
        if (lower === upper) return sorted[lower];
        return sorted[lower] + (idx - lower) * (sorted[upper] - sorted[lower]);
      }

      // Helper to compute boxplot stats for a group
      function computeBoxplot(results, metric, groupKey, testName) {
        const values = results
          .filter(r => r[metric] !== null)
          .map(r => r[metric])
          .sort((a, b) => a - b);

        if (values.length === 0) return null;

        return {
          group: groupKey,
          test: testName,
          min: values[0],
          q1: percentile(values, 25),
          median: percentile(values, 50),
          q3: percentile(values, 75),
          max: values[values.length - 1],
          count: values.length,
        };
      }

      for (const metric of metrics) {
        const boxplotData = [];

        // For efficiency metric, exclude flagged results with bad power data
        let metricFiltered = filtered;
        if (metric === 'fps_per_watt') {
          metricFiltered = filtered.filter(r =>
            r.avg_watts !== null &&
            r.avg_watts >= 3.0 &&
            (!r.data_quality_flags || !r.data_quality_flags.includes('power_too_low'))
          );
        }

        // Group by generation
        const byGenAndTest = {};
        for (const r of metricFiltered) {
          let groupKey;

          // Determine group
          if (r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake') {
            groupKey = 'U1';
          } else if (r.architecture === 'Arrow Lake') {
            groupKey = 'U2';
          } else if (r.architecture === 'Alchemist' || r.architecture === 'Battlemage') {
            groupKey = 'Arc';
          } else if (r.cpu_generation !== null) {
            groupKey = String(r.cpu_generation);
          } else {
            continue; // Skip if no generation info
          }

          const key = `${groupKey}|${r.test_name}`;
          if (!byGenAndTest[key]) byGenAndTest[key] = [];
          byGenAndTest[key].push(r);
        }

        // Compute stats for each group+test
        for (const [key, results] of Object.entries(byGenAndTest)) {
          const [groupKey, testName] = key.split('|');
          const stats = computeBoxplot(results, metric, groupKey, testName);
          if (stats) boxplotData.push(stats);
        }

        state.boxplotData[metric] = boxplotData;
        updateChart(metric);
      }
    } catch (e) {
      console.error('Failed to fetch boxplot data:', e);
    }
  }

  // Update Chart.js chart
  function updateChart(metric) {
    const chartId = {
      'avg_fps': 'fps-chart',
      'avg_watts': 'watts-chart',
      'fps_per_watt': 'efficiency-chart',
    }[metric];

    const canvas = document.getElementById(chartId);
    const boxplotData = state.boxplotData[metric] || [];

    // Group by generation and sort (numeric ascending, then U1, U2, Arc at the end)
    // Filter out generations < 6
    const allGroups = [...new Set(boxplotData.map(d => d.group))];
    const numericGroups = allGroups
      .filter(g => !isNaN(parseInt(g)) && parseInt(g) >= 6)
      .sort((a, b) => parseInt(a) - parseInt(b));
    // Sort non-numeric groups in specific order: U1, U2, Arc
    const nonNumericOrder = ['U1', 'U2', 'Arc'];
    const nonNumericGroups = allGroups
      .filter(g => isNaN(parseInt(g)))
      .sort((a, b) => {
        const aIdx = nonNumericOrder.indexOf(a);
        const bIdx = nonNumericOrder.indexOf(b);
        if (aIdx === -1 && bIdx === -1) return a.localeCompare(b);
        if (aIdx === -1) return 1;
        if (bIdx === -1) return -1;
        return aIdx - bIdx;
      });
    const generations = [...numericGroups, ...nonNumericGroups];
    const tests = [...new Set(boxplotData.map(d => d.test))];

    // Build datasets for Chart.js
    const datasets = tests.map(test => {
      const testData = boxplotData.filter(d => d.test === test);
      const colors = testColors[test] || { bg: 'rgba(148, 163, 184, 0.6)', border: 'rgb(148, 163, 184)' };

      return {
        label: test,
        data: generations.map(gen => {
          const point = testData.find(d => d.group === gen);
          return point ? point.median : null;
        }),
        backgroundColor: colors.bg,
        borderColor: colors.border,
        borderWidth: 1,
      };
    });

    // Highlight selected generations
    const selectedGens = state.filters.generation;

    // Destroy existing chart if any
    if (window.charts && window.charts[chartId]) {
      window.charts[chartId].destroy();
    }

    if (!window.charts) window.charts = {};

    window.charts[chartId] = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: generations.map(g => {
          if (g === 'U1') return 'Ultra 1';
          if (g === 'U2') return 'Ultra 2';
          if (isNaN(parseInt(g))) return g;
          return `Gen ${g}`;
        }),
        datasets,
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        onClick: (event, elements) => {
          if (elements.length > 0) {
            const index = elements[0].index;
            const group = generations[index];
            const isNumeric = !isNaN(parseInt(group));
            if (isNumeric) {
              window.toggleGenerationFilter(group);
            } else if (group === 'U1') {
              window.toggleGenerationFilter('ultra-1');
            } else if (group === 'U2') {
              window.toggleGenerationFilter('ultra-2');
            } else if (group === 'Arc') {
              window.toggleGenerationFilter('arc');
            }
          }
        },
        plugins: {
          legend: {
            position: 'top',
            labels: { color: '#94a3b8', font: { size: 11 } },
          },
          tooltip: {
            callbacks: {
              title: (items) => {
                const gen = generations[items[0].dataIndex];
                const isNumeric = !isNaN(parseInt(gen));
                const label = isNumeric ? `Gen ${gen}` : gen;
                const isSelected = isNumeric
                  ? selectedGens.includes(String(gen))
                  : (gen === 'Arc' && (state.filters.architecture.includes('Alchemist') || state.filters.architecture.includes('Battlemage')));
                const isClickable = isNumeric || gen === 'Arc';
                return `${label}${isSelected ? ' (filtered)' : ''}${isClickable ? ' - Click to toggle' : ''}`;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              color: (ctx) => {
                const gen = generations[ctx.index];
                const isNumeric = !isNaN(parseInt(gen));
                const isSelected = isNumeric
                  ? selectedGens.includes(String(gen))
                  : (gen === 'Arc' && (state.filters.architecture.includes('Alchemist') || state.filters.architecture.includes('Battlemage')));
                return isSelected ? '#3b82f6' : '#94a3b8';
              },
              font: (ctx) => {
                const gen = generations[ctx.index];
                const isNumeric = !isNaN(parseInt(gen));
                const isSelected = isNumeric
                  ? selectedGens.includes(String(gen))
                  : (gen === 'Arc' && (state.filters.architecture.includes('Alchemist') || state.filters.architecture.includes('Battlemage')));
                return { weight: isSelected ? 'bold' : 'normal' };
              }
            },
            grid: { color: '#334155' },
          },
          y: {
            ticks: { color: '#94a3b8' },
            grid: { color: '#334155' },
            title: {
              display: true,
              text: canvas.dataset.ylabel,
              color: '#94a3b8',
            },
          },
        },
      },
    });
  }

  // Fetch CPU scores (computed from local data using percentile ranking)
  async function fetchCpuScores() {
    try {
      // Group results by CPU
      const byCpu = {};
      for (const r of benchmarkData.results) {
        if (!byCpu[r.cpu_raw]) byCpu[r.cpu_raw] = [];
        byCpu[r.cpu_raw].push(r);
      }

      // Calculate average FPS and efficiency per CPU
      const cpuAvgFps = [];
      const cpuAvgEfficiency = [];

      for (const [cpu, results] of Object.entries(byCpu)) {
        const avgFps = results.reduce((sum, r) => sum + r.avg_fps, 0) / results.length;
        cpuAvgFps.push({ cpu, fps: avgFps });

        // Filter for validated efficiency results (exclude flagged data)
        const effResults = results.filter(r =>
          r.fps_per_watt !== null &&
          r.avg_watts !== null &&
          r.avg_watts >= 3.0 &&
          (!r.data_quality_flags || !r.data_quality_flags.includes('power_too_low'))
        );
        if (effResults.length > 0) {
          const avgEfficiency = effResults.reduce((sum, r) => sum + r.fps_per_watt, 0) / effResults.length;
          cpuAvgEfficiency.push({ cpu, eff: avgEfficiency });
        }
      }

      // Sort by FPS and efficiency (ascending for percentile calculation)
      cpuAvgFps.sort((a, b) => a.fps - b.fps);
      cpuAvgEfficiency.sort((a, b) => a.eff - b.eff);

      // Calculate percentile ranks (0-100 based on position in sorted array)
      const fpsPercentile = {};
      cpuAvgFps.forEach((item, idx) => {
        fpsPercentile[item.cpu] = Math.round((idx / (cpuAvgFps.length - 1)) * 100);
      });

      const effPercentile = {};
      cpuAvgEfficiency.forEach((item, idx) => {
        effPercentile[item.cpu] = Math.round((idx / (cpuAvgEfficiency.length - 1)) * 100);
      });

      // Get architecture codec support lookup
      const archCodecs = {};
      for (const arch of benchmarkData.architectures) {
        archCodecs[arch.architecture] = {
          av1: arch.av1_encode,
          hevc10: arch.hevc_10bit_encode,
          vp9: arch.vp9_encode,
        };
      }

      const scores = {};

      for (const [cpu, results] of Object.entries(byCpu)) {
        const perfScore = fpsPercentile[cpu] ?? 50;

        // Check if this CPU has any flagged results
        const hasFlaggedResults = results.some(r =>
          r.data_quality_flags && r.data_quality_flags.length > 0
        );

        // If CPU has no valid efficiency data (all flagged), set effScore to 0
        const effScore = effPercentile[cpu] ?? (hasFlaggedResults ? 0 : 50);

        // Codec support score (based on architecture)
        const arch = results[0]?.architecture;
        const codecs = arch ? archCodecs[arch] : null;
        let codecScore = 50; // Base score
        if (codecs) {
          if (codecs.av1) codecScore += 25;
          if (codecs.hevc10) codecScore += 15;
          if (codecs.vp9) codecScore += 10;
        }

        // Weighted average: 40% performance + 35% efficiency + 25% codec support
        const score = Math.round(perfScore * 0.4 + effScore * 0.35 + codecScore * 0.25);
        scores[cpu] = Math.min(100, Math.max(0, score));
      }

      state.cpuScores = scores;
    } catch (e) {
      console.error('Failed to fetch CPU scores:', e);
    }
  }

  // Fetch results table (from local data)
  async function fetchResults() {
    try {
      let filtered = filterResultsLocal(benchmarkData, state.filters);
      const total = filtered.length;

      // Sort
      const sortCol = state.sort.column;
      const sortOrder = state.sort.order;

      filtered = [...filtered].sort((a, b) => {
        let aVal, bVal;

        if (sortCol === 'score') {
          aVal = state.cpuScores[a.cpu_raw] ?? -1;
          bVal = state.cpuScores[b.cpu_raw] ?? -1;
        } else {
          aVal = a[sortCol];
          bVal = b[sortCol];
        }

        // Handle nulls
        if (aVal === null || aVal === undefined) aVal = sortOrder === 'asc' ? Infinity : -Infinity;
        if (bVal === null || bVal === undefined) bVal = sortOrder === 'asc' ? Infinity : -Infinity;

        // Compare
        if (typeof aVal === 'string') {
          return sortOrder === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
        }
        return sortOrder === 'asc' ? aVal - bVal : bVal - aVal;
      });

      // Paginate
      const start = state.pagination.offset;
      const end = start + state.pagination.limit;
      const results = filtered.slice(start, end);

      renderResults(results, total, state.cpuScores);

      // Update filtered count
      document.getElementById('filtered-results').textContent = total.toLocaleString();

      // Update pagination
      const currentPage = Math.floor(state.pagination.offset / state.pagination.limit) + 1;
      const totalPages = Math.ceil(total / state.pagination.limit);

      document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages}`;
      document.getElementById('prev-page').disabled = state.pagination.offset === 0;
      document.getElementById('next-page').disabled = state.pagination.offset + state.pagination.limit >= total;
    } catch (e) {
      console.error('Failed to fetch results:', e);
    }
  }

  // Render results table
  function renderResults(results, total, cpuScores = {}) {
    document.getElementById('results-count').textContent = `(${total.toLocaleString()} results)`;

    const tbody = document.getElementById('results-body');

    if (results.length === 0) {
      tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 2rem;">No results found</td></tr>';
      return;
    }

    tbody.innerHTML = results.map(r => {
      const testClass = r.test_name.includes('cpu') ? 'cpu' : r.test_name.includes('hevc') ? 'hevc' : 'h264';
      const date = new Date(r.submitted_at).toLocaleDateString();
      const cpuHtml = renderCpuName(r.cpu_raw, r.architecture, r.cpu_generation);
      const score = cpuScores[r.cpu_raw];
      const scoreClass = score >= 70 ? 'score-high' : score >= 40 ? 'score-mid' : 'score-low';

      // Generate data quality warning
      let warningHtml = '';
      if (r.data_quality_flags && r.data_quality_flags.length > 0) {
        const messages = {
          'power_too_low': 'Power reading < 3W (likely measurement error)',
          'efficiency_outlier': 'Efficiency > 400 fps/W (outlier)',
          'arrow_lake_power_issue': 'Arrow Lake: Known power measurement issue with intel_gpu_top'
        };
        const tooltip = r.data_quality_flags.map(f => messages[f] || f).join('; ');
        warningHtml = ` <span class="quality-warning" title="${escapeHtml(tooltip)}">⚠️</span>`;
      }

      // Generate quality badge (SSIM/PSNR)
      let qualityHtml = '-';
      if (r.ssim !== undefined && r.ssim !== null) {
        let qualityClass, qualityLabel;
        if (r.ssim >= 0.98) {
          qualityClass = 'quality-excellent';
          qualityLabel = 'Excellent';
        } else if (r.ssim >= 0.95) {
          qualityClass = 'quality-good';
          qualityLabel = 'Good';
        } else {
          qualityClass = 'quality-fair';
          qualityLabel = 'Fair';
        }
        const tooltip = `SSIM: ${r.ssim.toFixed(4)}${r.psnr ? ` | PSNR: ${r.psnr.toFixed(1)} dB` : ''}`;
        qualityHtml = `<span class="quality-badge ${qualityClass}" title="${tooltip}">${qualityLabel}</span>`;
      }

      return `
        <tr>
          <td class="cpu-cell">${cpuHtml}${warningHtml}</td>
          <td>${escapeHtml(r.architecture) || '-'}</td>
          <td><span class="test-badge ${testClass}">${escapeHtml(r.test_name)}</span></td>
          <td>${qualityHtml}</td>
          <td class="numeric">${r.avg_fps?.toFixed(1) || '-'}</td>
          <td class="numeric">${r.avg_watts?.toFixed(1) || '-'}</td>
          <td class="numeric">${r.fps_per_watt?.toFixed(2) || '-'}</td>
          <td class="numeric">${r.avg_speed ? r.avg_speed.toFixed(2) + 'x' : '-'}</td>
          <td class="numeric">${score !== undefined ? `<span class="score-badge ${scoreClass}">${score}</span>` : '-'}</td>
          <td>${date}</td>
        </tr>
      `;
    }).join('');
  }

  // Clear all filters
  function clearFilters() {
    state.filters = { generation: [], architecture: [], test: [], cpu: [], submitter: [], ecc: [] };
    state.pagination.offset = 0;

    // Uncheck all checkboxes
    document.querySelectorAll('[data-filter]').forEach(cb => {
      cb.checked = false;
    });

    // Clear search inputs
    document.getElementById('cpu-search').value = '';
    document.getElementById('submitter-search').value = '';

    onFiltersChanged();
  }

  // Event handlers setup
  function setupEventHandlers() {
    // Clear filters button
    document.getElementById('clear-filters').addEventListener('click', clearFilters);

    // Submitter search
    document.getElementById('submitter-search').addEventListener('input', (e) => {
      renderSubmitterList(e.target.value);
    });

    // CPU search
    document.getElementById('cpu-search').addEventListener('input', (e) => {
      renderCpuList(e.target.value);
    });

    // ECC filter checkboxes
    document.querySelectorAll('#ecc-list [data-filter="ecc"]').forEach(cb => {
      cb.addEventListener('change', handleFilterChange);
    });

    // Sort columns
    document.querySelectorAll('th[data-sort]').forEach(th => {
      th.addEventListener('click', () => {
        const column = th.dataset.sort;

        if (state.sort.column === column) {
          state.sort.order = state.sort.order === 'asc' ? 'desc' : 'asc';
        } else {
          state.sort.column = column;
          state.sort.order = 'desc';
        }

        // Update UI
        document.querySelectorAll('th[data-sort]').forEach(t => t.classList.remove('sorted-asc', 'sorted-desc'));
        th.classList.add(state.sort.order === 'asc' ? 'sorted-asc' : 'sorted-desc');

        fetchResults();
      });
    });

    // Pagination
    document.getElementById('prev-page').addEventListener('click', () => {
      state.pagination.offset = Math.max(0, state.pagination.offset - state.pagination.limit);
      fetchResults();
    });

    document.getElementById('next-page').addEventListener('click', () => {
      state.pagination.offset += state.pagination.limit;
      fetchResults();
    });

    // Results limit
    document.getElementById('results-limit').addEventListener('change', (e) => {
      state.pagination.limit = parseInt(e.target.value);
      state.pagination.offset = 0;
      fetchResults();
    });

    // Info banner toggle
    document.getElementById('hide-banner').addEventListener('click', () => {
      document.getElementById('info-banner').style.display = 'none';
      document.getElementById('show-banner').style.display = 'flex';
      localStorage.setItem('quicksync-banner-hidden', 'true');
    });

    document.getElementById('show-banner').addEventListener('click', () => {
      document.getElementById('info-banner').style.display = 'block';
      document.getElementById('show-banner').style.display = 'none';
      localStorage.removeItem('quicksync-banner-hidden');
    });

    // Check if banner was previously hidden
    if (localStorage.getItem('quicksync-banner-hidden') === 'true') {
      document.getElementById('info-banner').style.display = 'none';
      document.getElementById('show-banner').style.display = 'flex';
    }
  }

  // Populate concurrency leaderboard tables
  function populateConcurrencyTables() {
    if (!benchmarkData || !benchmarkData.concurrencyResults || benchmarkData.concurrencyResults.length === 0) {
      return;
    }

    const section = document.getElementById('concurrency-section');
    section.style.display = 'block';

    // Helper to get leaderboard for a test
    function getLeaderboard(testName, limit = 10) {
      const results = benchmarkData.concurrencyResults.filter(r => r.test_name === testName);
      const bestByPcu = {};

      for (const r of results) {
        if (!bestByPcu[r.cpu_raw] || r.max_concurrency > bestByPcu[r.cpu_raw].max_concurrency) {
          bestByPcu[r.cpu_raw] = r;
        }
      }

      return Object.values(bestByPcu)
        .sort((a, b) => b.max_concurrency - a.max_concurrency)
        .slice(0, limit);
    }

    // Populate H.264 table
    const h264Leaderboard = getLeaderboard('h264_1080p');
    const h264Tbody = document.querySelector('#h264-concurrency-table tbody');
    h264Tbody.innerHTML = h264Leaderboard.map((r, i) => `
      <tr>
        <td class="rank-cell">#${i + 1}</td>
        <td class="cpu-cell" title="${escapeHtml(r.cpu_raw)}">${escapeHtml(r.cpu_raw)}</td>
        <td>${escapeHtml(r.architecture || 'Unknown')}</td>
        <td class="streams-cell">${r.max_concurrency}x</td>
      </tr>
    `).join('');

    // Populate HEVC table
    const hevcLeaderboard = getLeaderboard('hevc_8bit');
    const hevcTbody = document.querySelector('#hevc-concurrency-table tbody');
    hevcTbody.innerHTML = hevcLeaderboard.map((r, i) => `
      <tr>
        <td class="rank-cell">#${i + 1}</td>
        <td class="cpu-cell" title="${escapeHtml(r.cpu_raw)}">${escapeHtml(r.cpu_raw)}</td>
        <td>${escapeHtml(r.architecture || 'Unknown')}</td>
        <td class="streams-cell">${r.max_concurrency}x</td>
      </tr>
    `).join('');
  }

  // Initialize
  async function init() {
    // Load benchmark data from R2 first
    try {
      const res = await fetch(DATA_URL);
      benchmarkData = await res.json();
      console.log(`Loaded ${benchmarkData.meta.totalResults} benchmark results from R2`);
    } catch (e) {
      console.error('Failed to load benchmark data:', e);
      return;
    }

    await Promise.all([
      fetchSummary(),
      fetchFilters(),
      fetchCpuScores(),
    ]);

    // Fetch initial filter counts (no filters applied)
    await fetchFilterCounts();

    await fetchResults();
    await fetchBoxplotData();

    // Populate concurrency leaderboard if data exists
    populateConcurrencyTables();

    setupEventHandlers();
  }

  // Load Chart.js and initialize
  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
  script.onload = init;
  document.head.appendChild(script);
</script>
