---
/**
 * CPU Generation Detail Page
 * Dynamic route: /cpu/gen/8, /cpu/gen/12, /cpu/gen/ultra-1, etc.
 *
 * Uses getStaticPaths() for static site generation (SSG).
 * Data is loaded client-side from R2 JSON.
 */

import Layout from '../../../layouts/Layout.astro';

// Define all valid generations for static path generation
export function getStaticPaths() {
  const generations = [
    '6', '7', '8', '9', '10', '11', '12', '13', '14',
    'ultra-1', 'ultra-2',
    'arc'
  ];

  return generations.map(gen => ({
    params: { gen }
  }));
}

const { gen } = Astro.params;

// Data URL - supports test data mode via PUBLIC_TEST_DATA env var
const dataUrl = import.meta.env.PUBLIC_TEST_DATA === 'true'
  ? '/test-data.json'
  : 'https://pub-c66d7559b64a430ca682a4bd624f04d8.r2.dev/benchmarks.json';

// Generation display names for initial render
const generationNames: Record<string, string> = {
  '6': '6th Gen (Skylake)',
  '7': '7th Gen (Kaby Lake)',
  '8': '8th Gen (Coffee Lake)',
  '9': '9th Gen (Coffee Lake Refresh)',
  '10': '10th Gen (Comet Lake)',
  '11': '11th Gen (Rocket/Tiger Lake)',
  '12': '12th Gen (Alder Lake)',
  '13': '13th Gen (Raptor Lake)',
  '14': '14th Gen (Raptor Lake Refresh)',
  'ultra-1': 'Intel Core Ultra Series 1',
  'ultra-2': 'Intel Core Ultra Series 2',
  'arc': 'Intel Arc GPUs',
};

const displayName = generationNames[gen || ''] || `Generation ${gen}`;
const pageTitle = `${displayName} - QuickSync Benchmarks`;

// Timeline for navigation
const allGens = ['6', '7', '8', '9', '10', '11', '12', '13', '14', 'ultra-1', 'ultra-2', 'arc'];
const currentIdx = allGens.indexOf(gen || '');
const prevGen = currentIdx > 0 ? allGens[currentIdx - 1] : null;
const nextGen = currentIdx < allGens.length - 1 ? allGens[currentIdx + 1] : null;
---

<Layout title={pageTitle}>
  <div class="container">
    <!-- Header with navigation -->
    <div class="page-header">
      <div class="nav-arrows">
        {prevGen ? (
          <a href={`/cpu/gen/${prevGen}`} class="nav-prev">
            &larr; {generationNames[prevGen]}
          </a>
        ) : <span class="nav-placeholder" />}
      </div>

      <div class="header-center">
        <h1 id="page-title">{displayName}</h1>
        <span id="arch-subtitle" class="arch-subtitle"></span>
      </div>

      <div class="nav-arrows">
        {nextGen ? (
          <a href={`/cpu/gen/${nextGen}`} class="nav-next">
            {generationNames[nextGen]} &rarr;
          </a>
        ) : <span class="nav-placeholder" />}
      </div>
    </div>

    <!-- Timeline -->
    <section class="timeline-section card">
      <h2>Generation Timeline</h2>
      <div class="timeline-slider" id="timeline-slider">
        {allGens.map(g => (
          <a
            href={`/cpu/gen/${g}`}
            class:list={['timeline-item', { active: g === gen }]}
          >
            {/^\d+$/.test(g) ? `${g}th` : g.replace('-', ' ').replace('ultra', 'Ultra ')}
          </a>
        ))}
      </div>
    </section>

    <!-- Loading state -->
    <div id="loading-state" class="loading-state">
      <p>Loading generation data...</p>
    </div>

    <!-- Error state -->
    <div id="error-state" class="error-state" style="display: none;">
      <h2>Failed to Load Data</h2>
      <p id="error-message"></p>
      <a href="/" class="back-link">&larr; Back to Dashboard</a>
    </div>

    <!-- Content (populated by JS) -->
    <div id="content" style="display: none;">
      <!-- TL;DR Section -->
      <section class="tldr-section card">
        <h2>TL;DR</h2>
        <p class="tldr-text" id="tldr-text"></p>

        <div class="tldr-stats" id="tldr-stats">
          <div class="tldr-stats-grid">
            <div class="tldr-stat-card">
              <div class="tldr-stat-label">Avg FPS</div>
              <div class="tldr-stat-value" id="stat-fps">—</div>
              <div class="tldr-stat-diff" id="stat-fps-diff"></div>
            </div>
            <div class="tldr-stat-card">
              <div class="tldr-stat-label">Efficiency</div>
              <div class="tldr-stat-value" id="stat-efficiency">—</div>
              <div class="tldr-stat-diff" id="stat-efficiency-diff"></div>
            </div>
            <div class="tldr-stat-card">
              <div class="tldr-stat-label">Avg Power</div>
              <div class="tldr-stat-value" id="stat-watts">—</div>
            </div>
            <div class="tldr-stat-card">
              <div class="tldr-stat-label">Results</div>
              <div class="tldr-stat-value" id="stat-results">—</div>
              <div class="tldr-stat-sub" id="stat-cpus"></div>
            </div>
          </div>

          <!-- Charts -->
          <div class="tldr-comparison-charts" id="charts-container">
            <div class="tldr-chart-container">
              <canvas id="gen-fps-chart"></canvas>
            </div>
            <div class="tldr-chart-container">
              <canvas id="gen-watts-chart"></canvas>
            </div>
            <div class="tldr-chart-container">
              <canvas id="gen-efficiency-chart"></canvas>
            </div>
          </div>

          <div id="baseline-note" class="tldr-baseline-note" style="display: none;">
            <span class="baseline-badge">Baseline</span>
            8th Gen Coffee Lake is the reference baseline for all efficiency comparisons.
          </div>
        </div>
      </section>

      <!-- Codec Support -->
      <section class="card">
        <h2>Codec Support</h2>
        <div class="codec-matrix" id="codec-matrix"></div>
      </section>

      <!-- Architecture Details -->
      <section id="arch-details-section" style="display: none;">
        <h2>Architecture Details</h2>
        <div class="arch-details-grid" id="arch-details-grid"></div>
      </section>

      <!-- Concurrency Results -->
      <div id="concurrency-section" class="concurrency-section" style="display: none;">
        <div class="section-header">
          <h3>Concurrency Results</h3>
          <span class="section-subtitle">Maximum simultaneous streams at realtime speed (≥1.0x)</span>
        </div>
        <div class="concurrency-tables" id="concurrency-tables"></div>
      </div>

      <!-- Benchmark Data -->
      <section class="benchmark-section card">
        <h2>
          Benchmark Data
          <span class="data-count" id="data-count"></span>
        </h2>
        <div class="test-stats" id="test-stats">
          <table>
            <thead>
              <tr>
                <th>Test</th>
                <th class="numeric">Avg FPS</th>
                <th class="numeric">Min</th>
                <th class="numeric">Max</th>
                <th class="numeric">FPS/Watt</th>
              </tr>
            </thead>
            <tbody id="test-stats-body"></tbody>
          </table>
        </div>
      </section>

      <!-- CPU Models -->
      <section class="cpu-models-section card">
        <h2>CPUs in This Generation</h2>
        <div id="winner-callout" class="winner-callout" style="display: none;"></div>
        <div class="cpu-grid" id="cpu-models-grid">
          <div class="cpu-grid-header">CPU Model</div>
          <div class="cpu-grid-header text-right">Score</div>
          <div class="cpu-grid-header text-right">Avg FPS</div>
          <div class="cpu-grid-header text-right">Avg Watts</div>
          <div class="cpu-grid-header text-right">FPS/Watt</div>
          <div class="cpu-grid-header text-right">Results</div>
        </div>
      </section>

      <!-- Pricing Links -->
      <section class="pricing-section card" id="pricing-section">
        <h2>Find This CPU</h2>
        <p class="pricing-note" id="pricing-note"></p>
        <div class="pricing-links" id="pricing-links"></div>
      </section>
    </div>
  </div>
</Layout>

<style is:global>
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
  }

  /* Page Header */
  .page-header {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
  }

  .header-center {
    text-align: center;
  }

  .header-center h1 {
    font-size: 2rem;
    font-weight: 700;
    margin: 0;
  }

  .arch-subtitle {
    display: block;
    font-size: 1rem;
    color: var(--color-text-muted);
    margin-top: 0.25rem;
  }

  .nav-arrows {
    display: flex;
  }

  .nav-arrows:first-child {
    justify-content: flex-start;
  }

  .nav-arrows:last-child {
    justify-content: flex-end;
  }

  .nav-prev, .nav-next {
    padding: 0.5rem 1rem;
    background: var(--color-bg-card);
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    font-size: 0.875rem;
    transition: all 0.2s;
  }

  .nav-prev:hover, .nav-next:hover {
    background: var(--color-bg);
    border-color: var(--color-accent);
    text-decoration: none;
  }

  .nav-placeholder {
    width: 120px;
  }

  /* Timeline Slider */
  .timeline-slider {
    display: flex;
    gap: 0.5rem;
    overflow-x: auto;
    padding: 0.5rem 0;
  }

  .timeline-item {
    padding: 0.5rem 1rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    font-size: 0.75rem;
    white-space: nowrap;
    transition: all 0.2s;
  }

  .timeline-item:hover {
    border-color: var(--color-accent);
    text-decoration: none;
  }

  .timeline-item.active {
    background: var(--color-accent);
    border-color: var(--color-accent);
    color: white;
  }

  /* Sections */
  section {
    margin-bottom: 1.5rem;
  }

  section h2 {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .data-count {
    font-size: 0.75rem;
    font-weight: 400;
    color: var(--color-text-muted);
  }

  /* TL;DR Section */
  .tldr-section {
    background: linear-gradient(135deg, var(--color-bg-secondary) 0%, rgba(59, 130, 246, 0.05) 100%);
    border: 2px solid var(--color-accent);
    box-shadow: 0 4px 24px rgba(59, 130, 246, 0.15);
  }

  .tldr-text {
    font-size: 1rem;
    line-height: 1.7;
    color: var(--color-text);
    margin-bottom: 1.25rem;
  }

  .tldr-stats {
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
  }

  .tldr-stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    margin-bottom: 1.25rem;
  }

  @media (max-width: 768px) {
    .tldr-stats-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  .tldr-stat-card {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 0.875rem;
    text-align: center;
  }

  .tldr-stat-label {
    font-size: 0.6875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    margin-bottom: 0.375rem;
  }

  .tldr-stat-value {
    font-size: 1.375rem;
    font-weight: 700;
    color: var(--color-text);
  }

  .tldr-stat-unit {
    font-size: 0.75rem;
    font-weight: 400;
    color: var(--color-text-muted);
  }

  .tldr-stat-diff {
    font-size: 0.6875rem;
    font-weight: 600;
    margin-top: 0.25rem;
  }

  .tldr-stat-diff.positive {
    color: #22c55e;
  }

  .tldr-stat-diff.negative {
    color: #ef4444;
  }

  .tldr-stat-sub {
    font-size: 0.6875rem;
    color: var(--color-text-muted);
    margin-top: 0.25rem;
  }

  /* Charts */
  .tldr-comparison-charts {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .tldr-chart-container {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 1rem;
    height: 220px;
  }

  @media (max-width: 768px) {
    .tldr-chart-container {
      height: 180px;
    }
  }

  .tldr-baseline-note {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-top: 1rem;
  }

  .baseline-badge {
    display: inline-block;
    font-size: 0.625rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0.25rem 0.5rem;
    background: var(--color-accent);
    color: white;
    border-radius: 0.25rem;
  }

  /* Codec Matrix */
  .codec-matrix {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.75rem;
  }

  .codec-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    font-size: 0.875rem;
  }

  .codec-item.supported {
    border-color: #22c55e;
    background: rgba(34, 197, 94, 0.1);
  }

  .codec-item.unsupported {
    opacity: 0.5;
  }

  .codec-icon {
    font-size: 1rem;
  }

  /* Architecture Details - card boxes like TL;DR stats */
  #arch-details-section {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
  }

  #arch-details-section h2 {
    font-size: 1.125rem;
    font-weight: 700;
    margin-bottom: 1rem;
    color: var(--color-text);
  }

  .arch-details-grid {
    display: block;
  }

  /* Legacy single-row grid for single-variant display */
  .arch-details-grid.single-variant-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 0.75rem;
  }

  .arch-detail-item {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    padding: 0.875rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    text-align: center;
  }

  .arch-detail-label {
    font-size: 0.6875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
  }

  .arch-detail-value {
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-text);
  }

  .arch-detail-sublabel {
    font-size: 0.6875rem;
    color: var(--color-text-muted);
  }

  @media (max-width: 600px) {
    .arch-details-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  /* Die Variants - multiple variants display */
  .arch-variants-intro {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1.25rem;
    flex-wrap: wrap;
  }

  .variant-badge {
    display: inline-block;
    font-size: 0.6875rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0.25rem 0.5rem;
    background: var(--color-accent);
    color: white;
    border-radius: 0.25rem;
  }

  .variant-intro-text {
    font-size: 0.875rem;
    color: var(--color-text-muted);
  }

  .arch-variants-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }

  @media (max-width: 900px) {
    .arch-variants-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Single variant - full width to match other content sections */
  .arch-single-variant {
    /* No max-width - let it fill the container like other sections */
  }

  .arch-variant-card {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .arch-variant-header {
    padding: 1rem 1.25rem;
    background: rgba(59, 130, 246, 0.1);
    border-bottom: 1px solid var(--color-border);
  }

  .variant-codename {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--color-text);
    margin: 0;
  }

  /* Tested CPUs badges */
  .variant-tested-cpus {
    display: flex;
    flex-wrap: wrap;
    gap: 0.375rem;
    padding: 0.875rem 1.25rem;
    border-top: 1px solid var(--color-border);
    background: rgba(59, 130, 246, 0.03);
    margin-top: auto;
  }

  .variant-tested-cpus-label {
    font-size: 0.6875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    width: 100%;
    margin-bottom: 0.25rem;
  }

  .cpu-badge {
    display: inline-block;
    font-size: 0.75rem;
    font-weight: 500;
    padding: 0.25rem 0.5rem;
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: 0.25rem;
    color: var(--color-text);
  }

  .cpu-badge-more {
    color: var(--color-text-muted);
    font-style: italic;
  }

  .cpu-badge-none {
    color: var(--color-text-muted);
    font-style: italic;
    border-style: dashed;
  }

  /* Variant details - vertical list layout */
  .arch-variant-details {
    padding: 0;
    flex: 1;
  }

  .variant-detail-row {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 0.75rem 1.25rem;
    border-bottom: 1px solid var(--color-border);
  }

  .variant-detail-row:last-child {
    border-bottom: none;
  }

  .variant-detail-label {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
  }

  .variant-detail-value {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--color-text);
    text-align: right;
    max-width: 60%;
  }

  .variant-detail-sublabel {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    font-weight: 400;
  }

  /* iGPU tier badge */
  .igpu-tier {
    display: inline-block;
    font-size: 0.625rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    padding: 0.125rem 0.375rem;
    border-radius: 0.1875rem;
    margin-left: 0.5rem;
    vertical-align: middle;
  }

  .igpu-tier-entry {
    background: rgba(156, 163, 175, 0.2);
    color: #9ca3af;
  }

  .igpu-tier-mid {
    background: rgba(59, 130, 246, 0.2);
    color: #3b82f6;
  }

  .igpu-tier-high {
    background: rgba(34, 197, 94, 0.2);
    color: #22c55e;
  }

  /* Process info link */
  .process-info-link {
    color: var(--color-accent);
    text-decoration: none;
    cursor: help;
    border-bottom: 1px dotted var(--color-accent);
  }

  .process-info-link:hover {
    opacity: 0.8;
  }

  /* Concurrency Section - matches index.astro styling */
  .concurrency-section {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
  }

  .concurrency-section .section-header {
    display: flex;
    align-items: baseline;
    gap: 1rem;
    margin-bottom: 1.25rem;
    flex-wrap: wrap;
  }

  .concurrency-section .section-header h3 {
    font-size: 1.125rem;
    font-weight: 700;
    color: var(--color-text);
    margin: 0;
  }

  .concurrency-section .section-subtitle {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
  }

  .concurrency-tables {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }

  @media (max-width: 768px) {
    .concurrency-tables {
      grid-template-columns: 1fr;
    }
  }

  .concurrency-table-wrapper {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 1rem;
  }

  .concurrency-table-wrapper h4 {
    font-size: 0.9375rem;
    font-weight: 600;
    color: var(--color-text);
    margin: 0 0 0.75rem 0;
  }

  .concurrency-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.8125rem;
  }

  .concurrency-table th {
    text-align: left;
    padding: 0.5rem 0.75rem;
    font-weight: 600;
    font-size: 0.6875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    border-bottom: 1px solid var(--color-border);
  }

  .concurrency-table td {
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid var(--color-border);
    color: var(--color-text);
  }

  .concurrency-table tbody tr:last-child td {
    border-bottom: none;
  }

  .concurrency-table tr:hover td {
    background: rgba(59, 130, 246, 0.05);
  }

  .concurrency-table .rank-cell {
    font-weight: 700;
    color: var(--color-accent);
    width: 50px;
  }

  .concurrency-table .streams-cell {
    font-weight: 700;
    font-size: 0.9375rem;
    color: var(--color-success, #10b981);
    text-align: right;
  }

  .concurrency-table .cpu-cell {
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Test Stats Table */
  .test-stats {
    overflow-x: auto;
  }

  .test-stats table {
    width: 100%;
    border-collapse: collapse;
  }

  .test-stats th {
    text-align: left;
    padding: 0.75rem;
    font-weight: 500;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    border-bottom: 2px solid var(--color-border);
  }

  .test-stats th.numeric {
    text-align: right;
  }

  .test-stats td {
    padding: 0.75rem;
    border-bottom: 1px solid var(--color-border);
    font-size: 0.875rem;
  }

  .test-stats td.numeric {
    text-align: right;
    font-variant-numeric: tabular-nums;
  }

  .test-badge {
    display: inline-block;
    padding: 0.125rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-weight: 500;
    background-color: var(--color-bg);
  }

  .test-badge.h264 { color: #22c55e; }
  .test-badge.hevc { color: #3b82f6; }
  .test-badge.cpu { color: #f59e0b; }

  /* CPU Models Grid */
  .cpu-grid {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr 1fr 1fr;
    gap: 0;
  }

  .cpu-grid-header {
    padding: 0.75rem;
    font-weight: 500;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
    border-bottom: 2px solid var(--color-border);
  }

  .cpu-grid-cell {
    padding: 0.75rem;
    font-size: 0.875rem;
    border-bottom: 1px solid var(--color-border);
    font-variant-numeric: tabular-nums;
  }

  .text-right {
    text-align: right;
  }

  /* Winner Callout */
  .winner-callout {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 183, 0, 0.05) 100%);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .winner-badge {
    display: inline-block;
    font-size: 0.625rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0.25rem 0.5rem;
    background: linear-gradient(135deg, #ffd700, #ffb700);
    color: #1a1a1a;
    border-radius: 0.25rem;
  }

  .winner-name {
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-text);
  }

  .winner-reason {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    flex: 1;
  }

  /* Pricing Links */
  .pricing-note {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: 1rem;
  }

  .pricing-links {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .pricing-link {
    padding: 0.5rem 1rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    font-size: 0.875rem;
    transition: all 0.2s;
  }

  .pricing-link:hover {
    border-color: var(--color-accent);
    text-decoration: none;
  }

  /* States */
  .loading-state, .error-state {
    text-align: center;
    padding: 4rem 2rem;
  }

  .error-state h2 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
  }

  .back-link {
    display: inline-block;
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: var(--color-accent);
    color: white;
    border-radius: 0.375rem;
  }

  .back-link:hover {
    background: var(--color-accent-hover);
    text-decoration: none;
  }

  @media (max-width: 768px) {
    .page-header {
      grid-template-columns: 1fr;
      text-align: center;
    }

    .nav-arrows {
      justify-content: center !important;
    }

    .nav-placeholder {
      display: none;
    }
  }
</style>

<script is:inline define:vars={{ gen, dataUrl }}>
  const DATA_URL = dataUrl;

  // Generation info
  const generationInfo = {
    '6': { display_name: '6th Gen (Skylake)', architectures: ['Skylake'] },
    '7': { display_name: '7th Gen (Kaby Lake)', architectures: ['Kaby Lake'] },
    '8': { display_name: '8th Gen (Coffee Lake)', architectures: ['Coffee Lake', 'Coffee Lake Refresh'] },
    '9': { display_name: '9th Gen (Coffee Lake Refresh)', architectures: ['Coffee Lake Refresh'] },
    '10': { display_name: '10th Gen (Comet Lake)', architectures: ['Comet Lake', 'Ice Lake'] },
    '11': { display_name: '11th Gen (Rocket/Tiger Lake)', architectures: ['Rocket Lake', 'Tiger Lake'] },
    '12': { display_name: '12th Gen (Alder Lake)', architectures: ['Alder Lake', 'Alder Lake-N'] },
    '13': { display_name: '13th Gen (Raptor Lake)', architectures: ['Raptor Lake'] },
    '14': { display_name: '14th Gen (Raptor Lake Refresh)', architectures: ['Raptor Lake Refresh'] },
    'ultra-1': { display_name: 'Intel Core Ultra Series 1', architectures: ['Meteor Lake', 'Lunar Lake'] },
    'ultra-2': { display_name: 'Intel Core Ultra Series 2', architectures: ['Arrow Lake'] },
    'arc': { display_name: 'Intel Arc GPUs', architectures: ['Alchemist', 'Battlemage', 'Arc Alchemist'] },
  };

  function avg(values) {
    if (values.length === 0) return 0;
    return values.reduce((a, b) => a + b, 0) / values.length;
  }

  function stripCpuBranding(cpu) {
    return cpu
      .replace(/Intel\(R\)\s*/gi, '')
      .replace(/Core\(TM\)\s*/gi, '')
      .replace(/\s+CPU\s*@\s*[\d.]+GHz/gi, '')
      .replace(/\s+/g, ' ')
      .trim();
  }

  async function loadData() {
    try {
      const response = await fetch(DATA_URL);
      if (!response.ok) throw new Error(`Failed to load data: ${response.status}`);
      return await response.json();
    } catch (e) {
      throw new Error('Failed to load benchmark data');
    }
  }

  function getGenerationDetail(data, genId) {
    const info = generationInfo[genId];
    if (!info) return { success: false, error: 'Unknown generation' };

    const isNumericGen = /^\d+$/.test(genId);
    const genResults = data.results.filter(r => {
      if (isNumericGen) return r.cpu_generation === parseInt(genId);
      if (genId === 'ultra-1') return r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake';
      if (genId === 'ultra-2') return r.architecture === 'Arrow Lake';
      if (genId === 'arc') return r.architecture === 'Alchemist' || r.architecture === 'Battlemage' || r.architecture === 'Arc Alchemist';
      return false;
    });

    // Find ALL architectures that match this generation (for die variants)
    const allArchData = data.architectures.filter(a => info.architectures.includes(a.architecture));
    // Use the first one for codec support (should be same across variants)
    const archData = allArchData[0];

    const codecSupport = {
      h264_encode: archData?.h264_encode ?? true,
      hevc_8bit_encode: archData?.hevc_8bit_encode ?? false,
      hevc_10bit_encode: archData?.hevc_10bit_encode ?? false,
      vp9_encode: archData?.vp9_encode ?? false,
      av1_encode: archData?.av1_encode ?? false,
    };

    const uniqueCpus = new Set(genResults.map(r => r.cpu_raw));
    const avgFps = avg(genResults.map(r => r.avg_fps));
    const avgWatts = avg(genResults.filter(r => r.avg_watts !== null).map(r => r.avg_watts));
    // For efficiency, exclude flagged results with bad power data
    const validEfficiencyResults = genResults.filter(r =>
      r.fps_per_watt !== null &&
      r.avg_watts !== null &&
      r.avg_watts >= 3.0 &&
      (!r.data_quality_flags || !r.data_quality_flags.includes('power_too_low'))
    );
    const fpsPerWatt = avg(validEfficiencyResults.map(r => r.fps_per_watt));

    // Stats by test
    const byTest = {};
    for (const r of genResults) {
      if (!byTest[r.test_name]) byTest[r.test_name] = [];
      byTest[r.test_name].push(r);
    }

    const testStats = Object.entries(byTest).map(([test, results]) => {
      const validEff = results.filter(r =>
        r.fps_per_watt !== null &&
        r.avg_watts !== null &&
        r.avg_watts >= 3.0 &&
        (!r.data_quality_flags || !r.data_quality_flags.includes('power_too_low'))
      );
      return {
        test_name: test,
        count: results.length,
        avg_fps: avg(results.map(r => r.avg_fps)),
        min_fps: Math.min(...results.map(r => r.avg_fps)),
        max_fps: Math.max(...results.map(r => r.avg_fps)),
        avg_watts: avg(results.filter(r => r.avg_watts !== null).map(r => r.avg_watts)),
        fps_per_watt: avg(validEff.map(r => r.fps_per_watt)),
      };
    });

    // Baseline comparison (8th gen)
    const baseline8 = data.results.filter(r => r.cpu_generation === 8);
    const baselineFps = avg(baseline8.map(r => r.avg_fps));
    const baselineEfficiency = avg(baseline8.filter(r => r.fps_per_watt !== null).map(r => r.fps_per_watt));

    const fpsDiff = baselineFps > 0 ? Math.round(((avgFps - baselineFps) / baselineFps) * 100) : null;
    const effDiff = baselineEfficiency > 0 ? Math.round(((fpsPerWatt - baselineEfficiency) / baselineEfficiency) * 100) : null;

    // Baseline by test
    const baselineByTest = Object.keys(byTest).map(test => {
      const baseResults = baseline8.filter(r => r.test_name === test);
      return {
        test_name: test,
        avg_fps: avg(baseResults.map(r => r.avg_fps)),
        avg_watts: avg(baseResults.filter(r => r.avg_watts !== null).map(r => r.avg_watts)),
        fps_per_watt: avg(baseResults.filter(r => r.fps_per_watt !== null).map(r => r.fps_per_watt)),
      };
    });

    // CPU models with stats
    const cpuStats = {};
    for (const r of genResults) {
      if (!cpuStats[r.cpu_raw]) cpuStats[r.cpu_raw] = [];
      cpuStats[r.cpu_raw].push(r);
    }

    const cpuModels = Object.entries(cpuStats).map(([cpu, results]) => {
      const validEff = results.filter(r =>
        r.fps_per_watt !== null &&
        r.avg_watts !== null &&
        r.avg_watts >= 3.0 &&
        (!r.data_quality_flags || !r.data_quality_flags.includes('power_too_low'))
      );
      const hasFlaggedResults = results.some(r =>
        r.data_quality_flags && r.data_quality_flags.length > 0
      );
      return {
        cpu_raw: cpu,
        result_count: results.length,
        avg_fps: avg(results.map(r => r.avg_fps)),
        avg_watts: avg(results.filter(r => r.avg_watts !== null).map(r => r.avg_watts)),
        fps_per_watt: avg(validEff.map(r => r.fps_per_watt)),
        has_flagged: hasFlaggedResults,
      };
    });

    // Architecture details (die info) - support multiple variants
    // Match tested CPUs to their die variants using the pattern regex
    const archVariants = allArchData.map(arch => {
      // Find CPUs that match this variant's pattern
      let matchedCpus = [];
      if (arch.pattern) {
        try {
          const regex = new RegExp(arch.pattern);
          matchedCpus = Array.from(uniqueCpus).filter(cpu => {
            // Extract model from cpu_raw string for matching
            const modelMatch = cpu.match(/i[3579]-\d{4,5}[A-Z]?|Ultra \d \d{3}[A-Z]?/i);
            if (modelMatch) {
              return regex.test(modelMatch[0]);
            }
            return regex.test(cpu);
          });
        } catch (e) {
          console.warn('Invalid regex pattern:', arch.pattern);
        }
      }

      return {
        igpu_name: arch.igpu_name,
        igpu_codename: arch.igpu_codename,
        igpu_base_mhz: arch.igpu_base_mhz,
        igpu_boost_mhz: arch.igpu_boost_mhz,
        process_nm: arch.process_nm,
        max_p_cores: arch.max_p_cores,
        max_e_cores: arch.max_e_cores,
        tdp_range: arch.tdp_range,
        die_layout: arch.die_layout,
        gpu_eu_count: arch.gpu_eu_count,
        release_year: arch.release_year,
        release_quarter: arch.release_quarter,
        codename: arch.codename,
        pattern: arch.pattern,
        tested_cpus: matchedCpus,
      };
    });

    // For single-variant gens, keep backward compat
    const archDetails = archVariants.length > 0 ? archVariants[0] : null;
    const hasMultipleVariants = archVariants.length > 1;

    // Concurrency results for this generation
    const genConcurrency = (data.concurrencyResults || []).filter(r => {
      if (isNumericGen) return r.cpu_generation === parseInt(genId);
      if (genId === 'ultra-1') return r.architecture === 'Meteor Lake' || r.architecture === 'Lunar Lake';
      if (genId === 'ultra-2') return r.architecture === 'Arrow Lake';
      if (genId === 'arc') return r.architecture === 'Alchemist' || r.architecture === 'Battlemage' || r.architecture === 'Arc Alchemist';
      return false;
    });

    // Group by test_name and find best per CPU
    const concurrencyByTest = {};
    for (const r of genConcurrency) {
      if (!concurrencyByTest[r.test_name]) concurrencyByTest[r.test_name] = {};
      if (!concurrencyByTest[r.test_name][r.cpu_raw] || r.max_concurrency > concurrencyByTest[r.test_name][r.cpu_raw].max_concurrency) {
        concurrencyByTest[r.test_name][r.cpu_raw] = r;
      }
    }

    return {
      success: true,
      display_name: info.display_name,
      architecture: { name: archData?.architecture ?? info.architectures[0] },
      arch_details: archDetails,
      arch_variants: archVariants,
      has_multiple_variants: hasMultipleVariants,
      codec_support: codecSupport,
      benchmark_stats: {
        total_results: genResults.length,
        unique_cpus: uniqueCpus.size,
        avg_fps: avgFps,
        avg_watts: avgWatts,
        fps_per_watt: fpsPerWatt,
        by_test: testStats,
      },
      baseline_comparison: { fps_diff_percent: fpsDiff, efficiency_diff_percent: effDiff },
      baseline_by_test: baselineByTest,
      cpu_models: cpuModels,
      concurrency_by_test: concurrencyByTest,
    };
  }

  function getCpuScores(data) {
    const byCpu = {};
    for (const r of data.results) {
      if (!byCpu[r.cpu_raw]) byCpu[r.cpu_raw] = [];
      byCpu[r.cpu_raw].push(r);
    }

    const cpuAvgFps = [];
    const cpuAvgEfficiency = [];

    for (const [cpu, results] of Object.entries(byCpu)) {
      cpuAvgFps.push({ cpu, fps: avg(results.map(r => r.avg_fps)) });
      // Filter for validated efficiency results (exclude flagged data)
      const effResults = results.filter(r =>
        r.fps_per_watt !== null &&
        r.avg_watts !== null &&
        r.avg_watts >= 3.0 &&
        (!r.data_quality_flags || !r.data_quality_flags.includes('power_too_low'))
      );
      if (effResults.length > 0) {
        cpuAvgEfficiency.push({ cpu, eff: avg(effResults.map(r => r.fps_per_watt)) });
      }
    }

    cpuAvgFps.sort((a, b) => a.fps - b.fps);
    cpuAvgEfficiency.sort((a, b) => a.eff - b.eff);

    const fpsPercentile = {};
    cpuAvgFps.forEach((item, idx) => {
      fpsPercentile[item.cpu] = Math.round((idx / (cpuAvgFps.length - 1)) * 100);
    });

    const effPercentile = {};
    cpuAvgEfficiency.forEach((item, idx) => {
      effPercentile[item.cpu] = Math.round((idx / (cpuAvgEfficiency.length - 1)) * 100);
    });

    const archCodecs = {};
    for (const arch of data.architectures) {
      archCodecs[arch.architecture] = {
        av1: arch.av1_encode,
        hevc10: arch.hevc_10bit_encode,
        vp9: arch.vp9_encode,
      };
    }

    const scores = {};
    for (const [cpu, results] of Object.entries(byCpu)) {
      const perfScore = fpsPercentile[cpu] ?? 50;

      // Check if this CPU has any flagged results
      const hasFlaggedResults = results.some(r =>
        r.data_quality_flags && r.data_quality_flags.length > 0
      );

      // If CPU has no valid efficiency data (all flagged), set effScore to 0
      const effScore = effPercentile[cpu] ?? (hasFlaggedResults ? 0 : 50);

      const arch = results[0]?.architecture;
      const codecs = arch ? archCodecs[arch] : null;
      let codecScore = 50;
      if (codecs) {
        if (codecs.av1) codecScore += 25;
        if (codecs.hevc10) codecScore += 15;
        if (codecs.vp9) codecScore += 10;
      }

      scores[cpu] = Math.min(100, Math.max(0, Math.round(perfScore * 0.4 + effScore * 0.35 + codecScore * 0.25)));
    }

    return scores;
  }

  function renderPage(genData, scores) {
    document.getElementById('loading-state').style.display = 'none';
    document.getElementById('content').style.display = 'block';

    // Update header
    document.getElementById('arch-subtitle').textContent = genData.architecture.name || '';

    // TL;DR text
    let tldrText = `<strong>${genData.display_name}</strong>`;
    if (genData.architecture.name) tldrText += ` (${genData.architecture.name})`;
    tldrText += '. Supports';
    if (genData.codec_support.h264_encode) tldrText += ' H.264';
    if (genData.codec_support.hevc_8bit_encode) tldrText += ', HEVC 8-bit';
    if (genData.codec_support.hevc_10bit_encode) tldrText += ', HEVC 10-bit';
    if (genData.codec_support.vp9_encode) tldrText += ', VP9';
    if (genData.codec_support.av1_encode) tldrText += ', AV1';
    tldrText += ' hardware encoding.';
    document.getElementById('tldr-text').innerHTML = tldrText;

    // Stats
    const stats = genData.benchmark_stats;
    document.getElementById('stat-fps').textContent = stats.avg_fps?.toFixed(1) || '—';
    document.getElementById('stat-efficiency').innerHTML = (stats.fps_per_watt?.toFixed(2) || '—') + '<span class="tldr-stat-unit"> FPS/W</span>';
    document.getElementById('stat-watts').innerHTML = (stats.avg_watts?.toFixed(1) || '—') + '<span class="tldr-stat-unit">W</span>';
    document.getElementById('stat-results').textContent = stats.total_results;
    document.getElementById('stat-cpus').textContent = stats.unique_cpus + ' CPUs';

    // Baseline comparison
    if (gen !== '8' && genData.baseline_comparison.fps_diff_percent !== null) {
      const fpsDiff = genData.baseline_comparison.fps_diff_percent;
      const fpsDiffEl = document.getElementById('stat-fps-diff');
      fpsDiffEl.textContent = (fpsDiff >= 0 ? '+' : '') + fpsDiff + '% vs 8th Gen';
      fpsDiffEl.className = 'tldr-stat-diff ' + (fpsDiff > 0 ? 'positive' : fpsDiff < 0 ? 'negative' : '');
    }

    if (gen !== '8' && genData.baseline_comparison.efficiency_diff_percent !== null) {
      const effDiff = genData.baseline_comparison.efficiency_diff_percent;
      const effDiffEl = document.getElementById('stat-efficiency-diff');
      effDiffEl.textContent = (effDiff >= 0 ? '+' : '') + effDiff + '% vs 8th Gen';
      effDiffEl.className = 'tldr-stat-diff ' + (effDiff > 0 ? 'positive' : effDiff < 0 ? 'negative' : '');
    }

    if (gen === '8') {
      document.getElementById('baseline-note').style.display = 'flex';
    }

    // Codec matrix
    const codecs = [
      { key: 'h264_encode', name: 'H.264' },
      { key: 'hevc_8bit_encode', name: 'HEVC 8-bit' },
      { key: 'hevc_10bit_encode', name: 'HEVC 10-bit' },
      { key: 'vp9_encode', name: 'VP9' },
      { key: 'av1_encode', name: 'AV1' },
    ];
    document.getElementById('codec-matrix').innerHTML = codecs.map(c => {
      const supported = genData.codec_support[c.key];
      const bgColor = supported ? 'rgba(34, 197, 94, 0.15)' : 'rgba(239, 68, 68, 0.1)';
      const borderColor = supported ? '#22c55e' : '#ef4444';
      const iconColor = supported ? '#22c55e' : '#ef4444';
      const icon = supported ? '✓' : '✗';
      return `<div style="display:flex;align-items:center;gap:0.5rem;padding:0.75rem 1rem;background:${bgColor};border:1px solid ${borderColor};border-radius:0.375rem;font-size:0.875rem">
        <span style="font-size:1.1rem;font-weight:bold;color:${iconColor}">${icon}</span>
        <span>${c.name}</span>
      </div>`;
    }).join('');

    // Test stats table
    document.getElementById('data-count').textContent = `${stats.total_results} results from ${stats.unique_cpus} CPUs`;
    document.getElementById('test-stats-body').innerHTML = stats.by_test.map(test => {
      const badgeClass = test.test_name.includes('hevc') ? 'hevc' : test.test_name.includes('cpu') ? 'cpu' : 'h264';
      return `<tr>
        <td><span class="test-badge ${badgeClass}">${test.test_name}</span></td>
        <td style="text-align:right;font-variant-numeric:tabular-nums">${test.avg_fps?.toFixed(1) || '—'}</td>
        <td style="text-align:right;font-variant-numeric:tabular-nums">${test.min_fps?.toFixed(1) || '—'}</td>
        <td style="text-align:right;font-variant-numeric:tabular-nums">${test.max_fps?.toFixed(1) || '—'}</td>
        <td style="text-align:right;font-variant-numeric:tabular-nums">${test.fps_per_watt?.toFixed(2) || '—'}</td>
      </tr>`;
    }).join('');

    // CPU models with scores
    const cpuModelsWithScores = genData.cpu_models.map(cpu => ({
      ...cpu,
      score: scores[cpu.cpu_raw] ?? null,
    })).sort((a, b) => {
      if (a.score === null && b.score === null) return 0;
      if (a.score === null) return 1;
      if (b.score === null) return -1;
      return b.score - a.score;
    });

    // Winner callout
    if (cpuModelsWithScores.length >= 2 && cpuModelsWithScores[0].score) {
      const winner = cpuModelsWithScores[0];
      const second = cpuModelsWithScores[1];
      let reason = [];
      if (winner.score && second.score && winner.score > second.score) {
        reason.push(`+${winner.score - second.score} points vs ${stripCpuBranding(second.cpu_raw)}`);
      }
      if (winner.fps_per_watt) {
        reason.push(`${winner.fps_per_watt.toFixed(1)} FPS/W efficiency`);
      }
      if (winner.score) {
        const label = winner.score >= 70 ? 'excellent' : winner.score >= 50 ? 'good' : 'moderate';
        reason.push(`${label} overall (${winner.score}/100)`);
      }
      document.getElementById('winner-callout').innerHTML = `
        <span class="winner-badge">Top Performer</span>
        <span class="winner-name">${stripCpuBranding(winner.cpu_raw)}</span>
        <span class="winner-reason">${reason.join(' • ')}</span>
      `;
      document.getElementById('winner-callout').style.display = 'flex';
    }

    const gridHtml = cpuModelsWithScores.map(cpu => {
      const scoreClass = cpu.score >= 70 ? 'score-high' : cpu.score >= 40 ? 'score-mid' : 'score-low';
      const hasWattsData = cpu.avg_watts > 0;
      const warningIcon = cpu.has_flagged ? ` <span class="quality-warning" title="Some results excluded from efficiency scoring due to data quality issues" style="cursor:help;color:#ff9800">⚠️</span>` : '';
      return `
        <div style="padding:0.75rem;font-size:0.875rem;border-bottom:1px solid var(--color-border)">${stripCpuBranding(cpu.cpu_raw)}${warningIcon}</div>
        <div style="padding:0.75rem;font-size:0.875rem;border-bottom:1px solid var(--color-border);text-align:right">${cpu.score !== null ? `<span class="score-badge ${scoreClass}">${cpu.score}</span>` : '—'}</div>
        <div style="padding:0.75rem;font-size:0.875rem;border-bottom:1px solid var(--color-border);text-align:right;font-variant-numeric:tabular-nums">${cpu.avg_fps?.toFixed(1) || '—'}</div>
        <div style="padding:0.75rem;font-size:0.875rem;border-bottom:1px solid var(--color-border);text-align:right;font-variant-numeric:tabular-nums">${hasWattsData ? cpu.avg_watts.toFixed(1) : '—'}</div>
        <div style="padding:0.75rem;font-size:0.875rem;border-bottom:1px solid var(--color-border);text-align:right;font-variant-numeric:tabular-nums">${hasWattsData ? cpu.fps_per_watt?.toFixed(2) : '—'}</div>
        <div style="padding:0.75rem;font-size:0.875rem;border-bottom:1px solid var(--color-border);text-align:right;font-variant-numeric:tabular-nums">${cpu.result_count}</div>`;
    }).join('');
    document.getElementById('cpu-models-grid').insertAdjacentHTML('beforeend', gridHtml);

    // Architecture details - support multiple die variants
    if (genData.arch_variants && genData.arch_variants.length > 0) {
      const hasMultipleVariants = genData.has_multiple_variants;

      // Process node explanations with links
      const processExplainers = {
        'Intel 7': { equiv: '~10nm ESF', url: 'https://en.wikipedia.org/wiki/Intel_7' },
        'Intel 4': { equiv: '~7nm EUV', url: 'https://en.wikipedia.org/wiki/Intel_4' },
        'Intel 3': { equiv: '~5nm class', url: 'https://en.wikipedia.org/wiki/Intel_3' },
        'Intel 20A': { equiv: '~3nm RibbonFET', url: 'https://en.wikipedia.org/wiki/Intel_20A' },
        'Intel 18A': { equiv: '~2nm class', url: 'https://en.wikipedia.org/wiki/Intel_18A' },
        '14nm': { equiv: '14nm++', url: 'https://en.wikipedia.org/wiki/14_nm_process' },
        '10nm': { equiv: '10nm SuperFin', url: 'https://en.wikipedia.org/wiki/10_nm_process' },
        'TSMC N6': { equiv: '~7nm EUV', url: 'https://en.wikipedia.org/wiki/TSMC_7nm_process' },
        'TSMC N5': { equiv: '5nm class', url: 'https://en.wikipedia.org/wiki/5_nm_process' },
        'TSMC N3': { equiv: '3nm class', url: 'https://en.wikipedia.org/wiki/3_nm_process' },
      };

      // iGPU tier based on EU count
      function getIgpuTier(euCount) {
        if (!euCount) return null;
        const eus = parseInt(euCount);
        if (eus >= 64) return { tier: 'High', class: 'igpu-tier-high' };
        if (eus >= 32) return { tier: 'Mid', class: 'igpu-tier-mid' };
        return { tier: 'Entry', class: 'igpu-tier-entry' };
      }

      // Helper to render tested CPUs badges
      function renderTestedCpus(cpus) {
        // Always show this section for consistent card heights
        if (!cpus || cpus.length === 0) {
          return `
            <div class="variant-tested-cpus">
              <div class="variant-tested-cpus-label">Tested CPUs</div>
              <span class="cpu-badge cpu-badge-none">No samples</span>
            </div>
          `;
        }
        const maxShow = 4;
        const shown = cpus.slice(0, maxShow).map(cpu => {
          const shortName = stripCpuBranding(cpu);
          return `<span class="cpu-badge">${shortName}</span>`;
        });
        if (cpus.length > maxShow) {
          shown.push(`<span class="cpu-badge cpu-badge-more">+${cpus.length - maxShow} more</span>`);
        }
        return `
          <div class="variant-tested-cpus">
            <div class="variant-tested-cpus-label">Tested CPUs</div>
            ${shown.join('')}
          </div>
        `;
      }

      // Helper to render a single variant's details in vertical list layout
      function renderVariantDetails(variant) {
        const rows = [];
        const igpuTier = getIgpuTier(variant.gpu_eu_count);

        // iGPU row - combined info
        if (variant.igpu_name) {
          const euStr = variant.gpu_eu_count ? ` (${variant.gpu_eu_count})` : '';
          const tierBadge = igpuTier ? `<span class="igpu-tier ${igpuTier.class}">${igpuTier.tier}</span>` : '';
          // Build sublabel with codename, tier badge, and clock speed
          const codenamePart = variant.igpu_codename || '';
          const clockPart = variant.igpu_boost_mhz ? `${variant.igpu_boost_mhz} MHz boost` : '';
          const sublabelText = [codenamePart, clockPart].filter(Boolean).join(' · ');
          rows.push(`
            <div class="variant-detail-row">
              <span class="variant-detail-label">iGPU</span>
              <span class="variant-detail-value">
                ${variant.igpu_name}${euStr}
                <br><span class="variant-detail-sublabel">${sublabelText}</span>${tierBadge}
              </span>
            </div>
          `);
        }

        // Cores row
        if (variant.max_p_cores !== null && variant.max_p_cores !== undefined) {
          let coreLabel = `${variant.max_p_cores}P`;
          if (variant.max_e_cores) {
            coreLabel += ` + ${variant.max_e_cores}E`;
          } else if (variant.max_e_cores === 0) {
            coreLabel += ' only';
          }
          rows.push(`
            <div class="variant-detail-row">
              <span class="variant-detail-label">Cores</span>
              <span class="variant-detail-value">${coreLabel}</span>
            </div>
          `);
        }

        // Process row with explainer link
        if (variant.process_nm) {
          const processInfo = processExplainers[variant.process_nm];
          let processHtml = variant.process_nm;
          if (processInfo) {
            processHtml = `<a href="${processInfo.url}" target="_blank" rel="noopener" class="process-info-link" title="${processInfo.equiv}">${variant.process_nm}</a>`;
            processHtml += `<br><span class="variant-detail-sublabel">${processInfo.equiv}</span>`;
          }
          rows.push(`
            <div class="variant-detail-row">
              <span class="variant-detail-label">Process</span>
              <span class="variant-detail-value">${processHtml}</span>
            </div>
          `);
        }

        // TDP row
        if (variant.tdp_range) {
          rows.push(`
            <div class="variant-detail-row">
              <span class="variant-detail-label">TDP</span>
              <span class="variant-detail-value">${variant.tdp_range}</span>
            </div>
          `);
        }

        // Released row
        if (variant.release_year) {
          const quarter = variant.release_quarter ? `Q${variant.release_quarter} ` : '';
          rows.push(`
            <div class="variant-detail-row">
              <span class="variant-detail-label">Released</span>
              <span class="variant-detail-value">${quarter}${variant.release_year}</span>
            </div>
          `);
        }

        return rows.join('');
      }

      let archHtml = '';

      if (hasMultipleVariants) {
        // Multi-variant layout with side-by-side cards
        archHtml = `
          <div class="arch-variants-intro">
            <span class="variant-badge">${genData.arch_variants.length} die variants</span>
            <span class="variant-intro-text">Different SKUs use different silicon with varying iGPU capabilities</span>
          </div>
          <div class="arch-variants-grid">
            ${genData.arch_variants.map(variant => `
              <div class="arch-variant-card">
                <div class="arch-variant-header">
                  <span class="variant-codename">${variant.codename || 'Unknown'}</span>
                </div>
                <div class="arch-variant-details">
                  ${renderVariantDetails(variant)}
                </div>
                ${renderTestedCpus(variant.tested_cpus)}
              </div>
            `).join('')}
          </div>
        `;
      } else {
        // Single variant - use same card structure but constrained width
        const variant = genData.arch_variants[0];
        archHtml = `
          <div class="arch-single-variant">
            <div class="arch-variant-card">
              <div class="arch-variant-header">
                <span class="variant-codename">${variant.codename || genData.architecture.name || 'Unknown'}</span>
              </div>
              <div class="arch-variant-details">
                ${renderVariantDetails(variant)}
              </div>
              ${renderTestedCpus(variant.tested_cpus)}
            </div>
          </div>
        `;
      }

      document.getElementById('arch-details-grid').innerHTML = archHtml;
      document.getElementById('arch-details-section').style.display = 'block';
    }

    // Concurrency results
    if (genData.concurrency_by_test && Object.keys(genData.concurrency_by_test).length > 0) {
      renderConcurrencySection(genData.concurrency_by_test);
    }

    // Pricing links
    const isNumeric = /^\d+$/.test(gen);
    if (isNumeric) {
      document.getElementById('pricing-note').textContent = `Search for ${genData.display_name} processors on popular marketplaces:`;
      document.getElementById('pricing-links').innerHTML = `
        <a href="https://www.ebay.com/sch/i.html?_nkw=intel+${gen}th+gen+cpu" target="_blank" rel="noopener" class="pricing-link">eBay</a>
        <a href="https://www.amazon.com/s?k=intel+${gen}th+gen+processor" target="_blank" rel="noopener" class="pricing-link">Amazon</a>
        <a href="https://www.newegg.com/p/pl?d=intel+${gen}th+gen" target="_blank" rel="noopener" class="pricing-link">Newegg</a>
      `;
    } else if (gen === 'arc') {
      document.getElementById('pricing-note').textContent = 'Search for Intel Arc discrete graphics cards:';
      document.getElementById('pricing-links').innerHTML = `
        <a href="https://www.ebay.com/sch/i.html?_nkw=intel+arc+gpu" target="_blank" rel="noopener" class="pricing-link">eBay</a>
        <a href="https://www.amazon.com/s?k=intel+arc+graphics+card" target="_blank" rel="noopener" class="pricing-link">Amazon</a>
        <a href="https://www.newegg.com/p/pl?d=intel+arc" target="_blank" rel="noopener" class="pricing-link">Newegg</a>
      `;
    } else {
      document.getElementById('pricing-note').textContent = `Search for ${genData.display_name} processors on popular marketplaces:`;
      document.getElementById('pricing-links').innerHTML = `
        <a href="https://www.ebay.com/sch/i.html?_nkw=intel+core+ultra+cpu" target="_blank" rel="noopener" class="pricing-link">eBay</a>
        <a href="https://www.amazon.com/s?k=intel+core+ultra+processor" target="_blank" rel="noopener" class="pricing-link">Amazon</a>
        <a href="https://www.newegg.com/p/pl?d=intel+core+ultra" target="_blank" rel="noopener" class="pricing-link">Newegg</a>
      `;
    }

    // Load Chart.js and render charts
    if (stats.by_test?.length > 0) {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
      script.onload = () => renderCharts(genData);
      document.head.appendChild(script);
    }
  }

  function renderConcurrencySection(concurrencyByTest) {
    const container = document.getElementById('concurrency-tables');
    if (!container) return;

    const testOrder = ['h264_1080p', 'hevc_8bit', 'h264_4k', 'hevc_4k_10bit'];
    const testLabels = {
      'h264_1080p': 'H.264 1080p',
      'hevc_8bit': 'HEVC 1080p',
      'h264_4k': 'H.264 4K',
      'hevc_4k_10bit': 'HEVC 4K 10-bit',
    };

    const sortedTests = Object.keys(concurrencyByTest).sort((a, b) => {
      const aIdx = testOrder.indexOf(a);
      const bIdx = testOrder.indexOf(b);
      if (aIdx === -1 && bIdx === -1) return a.localeCompare(b);
      if (aIdx === -1) return 1;
      if (bIdx === -1) return -1;
      return aIdx - bIdx;
    });

    const tablesHtml = sortedTests.map(testName => {
      const cpuResults = Object.values(concurrencyByTest[testName]);
      cpuResults.sort((a, b) => b.max_concurrency - a.max_concurrency);

      const testLabel = testLabels[testName] || testName;

      const rowsHtml = cpuResults.map((r, i) => {
        const cpuDisplay = stripCpuBranding(r.cpu_raw);
        return `<tr>
          <td class="rank-cell">#${i + 1}</td>
          <td class="cpu-cell">${cpuDisplay}</td>
          <td class="streams-cell">${r.max_concurrency}x</td>
        </tr>`;
      }).join('');

      return `
        <div class="concurrency-table-wrapper">
          <h4>${testLabel}</h4>
          <table class="concurrency-table">
            <thead>
              <tr>
                <th>Rank</th>
                <th>CPU</th>
                <th style="text-align: right">Max Streams</th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      `;
    }).join('');

    container.innerHTML = tablesHtml;
    document.getElementById('concurrency-section').style.display = 'block';
  }

  function renderCharts(genData) {
    const genColor = { bg: 'rgba(6, 182, 212, 0.7)', border: 'rgb(6, 182, 212)' };
    const baselineColor = { bg: 'rgba(120, 120, 130, 0.6)', border: 'rgb(120, 120, 130)' };

    const byTest = genData.benchmark_stats.by_test;
    const baselineByTest = genData.baseline_by_test || [];
    const isBaseline = gen === '8';

    function buildDatasets(metric) {
      const testNames = byTest.map(t => t.test_name);
      const datasets = [{
        label: genData.display_name,
        data: testNames.map(name => byTest.find(t => t.test_name === name)?.[metric] || 0),
        backgroundColor: genColor.bg,
        borderColor: genColor.border,
        borderWidth: 1,
      }];

      if (!isBaseline && baselineByTest.length > 0) {
        datasets.push({
          label: '8th Gen (Baseline)',
          data: testNames.map(name => baselineByTest.find(t => t.test_name === name)?.[metric] || 0),
          backgroundColor: baselineColor.bg,
          borderColor: baselineColor.border,
          borderWidth: 1,
        });
      }

      return datasets;
    }

    function createChart(canvasId, title, yLabel, metric) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;

      new Chart(canvas, {
        type: 'bar',
        data: { labels: byTest.map(t => t.test_name), datasets: buildDatasets(metric) },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top', labels: { color: '#f1f5f9', font: { size: 11 } } },
            title: { display: true, text: title, color: '#f1f5f9', font: { size: 13, weight: '600' } },
          },
          scales: {
            x: { ticks: { color: '#94a3b8', font: { size: 10 } }, grid: { color: '#334155' } },
            y: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' }, title: { display: true, text: yLabel, color: '#94a3b8' } },
          },
        },
      });
    }

    createChart('gen-fps-chart', 'Average FPS by Test Type', 'Frames per Second', 'avg_fps');
    createChart('gen-watts-chart', 'Average Power Usage by Test Type', 'Watts', 'avg_watts');
    createChart('gen-efficiency-chart', 'Efficiency (FPS per Watt) by Test Type', 'FPS/Watt', 'fps_per_watt');
  }

  function showError(message) {
    document.getElementById('loading-state').style.display = 'none';
    document.getElementById('error-state').style.display = 'block';
    document.getElementById('error-message').textContent = message;
  }

  // Initialize
  loadData()
    .then(data => {
      const genData = getGenerationDetail(data, gen);
      if (!genData.success) {
        showError(genData.error || 'Unknown generation');
        return;
      }
      const scores = getCpuScores(data);
      renderPage(genData, scores);
    })
    .catch(e => {
      showError(e.message);
    });
</script>
